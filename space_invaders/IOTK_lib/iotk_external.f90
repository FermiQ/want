! Input/Output Tool Kit (IOTK) 0.3.5
! Copyright (C) 2004 Giovanni Bussi
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Lesser General Public
! License as published by the Free Software Foundation; either
! version 2.1 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Lesser General Public License for more details.
!
! You should have received a copy of the GNU Lesser General Public
! License along with this library; if not, write to the Free Software
! Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
!
! PLEASE DO NOT EDIT THIS FILE !
! THIS FILE HAS BEEN GENERATED AUTOMATICALLY
! WITH SPREP 0.4.0 ON mer dic 29 14:56:05 CET 2004
!
!------------------------------------------------------------------------------!
! Inclusion of configuration file
#include "iotk_config.h"
!------------------------------------------------------------------------------!
!------------------------------------------------------------------------------!
! IOTK MACROS
! The macros are defined with -D option or inside iotk_config.h
! The default values are set here
! Maximum rank of an array
#ifndef __IOTK_MAXRANK
#  define __IOTK_MAXRANK 7
#endif
! Minimum value used in iotk_free_unit
#ifndef __IOTK_UNITMIN
#  define __IOTK_UNITMIN 90000
#endif
! Maximum value used in iotk_free_unit
#ifndef __IOTK_UNITMAX
#  define __IOTK_UNITMAX 99999
#endif
! Kind for header in binary files
#ifndef __IOTK_HEADER_KIND
#  define __IOTK_HEADER_KIND selected_int_kind(8)
#endif
! Character (or eventually string) for newline
! It may be adjusted for particular systems
! Unix    achar(10)
! Mac-OS  achar(13)
! Windows ? (now it should be a single byte)
#ifndef __IOTK_NEWLINE
#  define __IOTK_NEWLINE achar(10)
#endif
! Character for EOS
#ifndef __IOTK_EOS
#  define __IOTK_EOS achar(0)
#endif
! These are the default kinds, which depend on the options used
! during the library compilation
! Only default characters are implemented
#define __IOTK_CHARACTER1 iotk_defkind_character
! For logical, integer and real types, the c precompiler
! looks for defined kinds. If no kind is found, the default
! is used as __IOTK_type1
#ifndef __IOTK_LOGICAL1
#ifndef __IOTK_LOGICAL2
#ifndef __IOTK_LOGICAL3
#ifndef __IOTK_LOGICAL4
#define __IOTK_LOGICAL1 iotk_defkind_LOGICAL
#endif
#endif
#endif
#endif
#ifndef __IOTK_INTEGER1
#ifndef __IOTK_INTEGER2
#ifndef __IOTK_INTEGER3
#ifndef __IOTK_INTEGER4
#define __IOTK_INTEGER1 iotk_defkind_INTEGER
#endif
#endif
#endif
#endif
#ifndef __IOTK_REAL1
#ifndef __IOTK_REAL2
#ifndef __IOTK_REAL3
#ifndef __IOTK_REAL4
#define __IOTK_REAL1 iotk_defkind_REAL
#endif
#endif
#endif
#endif
! Complex are treated indentically to reals
! These lines map the definitions.
#ifdef __IOTK_REAL1
#define __IOTK_COMPLEX1 __IOTK_REAL1
#else
#undef __IOTK_COMPLEX1
#endif
#ifdef __IOTK_REAL2
#define __IOTK_COMPLEX2 __IOTK_REAL2
#else
#undef __IOTK_COMPLEX2
#endif
#ifdef __IOTK_REAL3
#define __IOTK_COMPLEX3 __IOTK_REAL3
#else
#undef __IOTK_COMPLEX3
#endif
#ifdef __IOTK_REAL4
#define __IOTK_COMPLEX4 __IOTK_REAL4
#else
#undef __IOTK_COMPLEX4
#endif
! If the binary format is not defined, use *
#ifndef __IOTK_BINARY_FORMAT
#define __IOTK_BINARY_FORMAT "*"
#endif

! Some check 
#if __IOTK_MAXRANK > 7
#  error
#endif
#if __IOTK_MAXRANK < 1
#  error
#endif

subroutine iotk_copyfile_x(source,dest,source_unit,dest_unit,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*), optional, intent(in) :: source
  character(len=*), optional, intent(in) :: dest
  integer,          optional, intent(in) :: source_unit
  integer,          optional, intent(in) :: dest_unit
  integer,          optional, intent(out):: ierr
  integer :: ierrl,unit1,unit2
  integer :: iostat
  character(len=iotk_linlenx) :: line
  iostat = 0
  ierrl  = 0
  if(present(source) .eqv. present(source_unit)) then
        call iotk_error_issue(ierrl,"iotk_copyfile_x",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Use exactly one between source and source_unit')
    goto 1
  end if
  if(present(dest)   .eqv. present(dest_unit)) then
        call iotk_error_issue(ierrl,"iotk_copyfile_x",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Use exactly one between dest and dest_unit')
    goto 1
  end if
  if(present(source)) then
    call iotk_free_unit(unit1,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_copyfile_x",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error searching for a free unit')
      goto 1
    end if
    open(unit1,file=trim(source),iostat=iostat)
    if(iostat/=0) then
          call iotk_error_issue(ierrl,"iotk_copyfile_x",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'messaggio')
    call iotk_error_write(ierrl,"sourcefile",trim(source))
    call iotk_error_write(ierrl,"sourceunit",unit1)
    call iotk_error_write(ierrl,"iostat",iostat)
      goto 1
    end if
  else
    unit1=source_unit
  end if
  if(present(dest)) then
    call iotk_free_unit(unit2,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_copyfile_x",__FILE__,__LINE__)
      goto 1
    end if
    open(unit2,file=trim(dest),iostat=iostat)
    if(iostat/=0) then
          call iotk_error_issue(ierrl,"iotk_copyfile_x",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error opening destination file')
    call iotk_error_write(ierrl,"destfile",trim(dest))
    call iotk_error_write(ierrl,"destunit",unit2)
    call iotk_error_write(ierrl,"iostat",iostat)
      goto 1
    end if
  else
    unit2=dest_unit
  end if
  do
    read (unit1,"(a)",iostat=iostat) line
    if(iostat<0) exit
    if(iostat/=0) then
           call iotk_error_issue(ierrl,"iotk_copyfile_x",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error reading source file')
    call iotk_error_write(ierrl,"sourceunit",unit1)
    call iotk_error_write(ierrl,"iostat",iostat)
       goto 1
    end if
    write(unit2,"(a)",iostat=iostat) trim(line)
    if(iostat/=0) then
           call iotk_error_issue(ierrl,"iotk_copyfile_x",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing destination file')
    call iotk_error_write(ierrl,"destunit",unit2)
    call iotk_error_write(ierrl,"iostat",iostat)
       goto 1
    end if 
  end do
  iostat=0
  if(present(source)) then
    close(unit1,iostat=iostat)
    if(iostat/=0) then
           call iotk_error_issue(ierrl,"iotk_copyfile_x",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error closing source file')
    call iotk_error_write(ierrl,"sourcefile",trim(source))
    call iotk_error_write(ierrl,"sourceunit",unit1)
    call iotk_error_write(ierrl,"iostat",iostat)
       goto 1
    end if 
  end if
  if(present(dest)) then
    close(unit2,iostat=iostat)
    if(iostat/=0) then
           call iotk_error_issue(ierrl,"iotk_copyfile_x",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error closing destination file')
    call iotk_error_write(ierrl,"destfile",dest)
    call iotk_error_write(ierrl,"destunit",unit2)
    call iotk_error_write(ierrl,"iostat",iostat)
       goto 1
    end if
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_copyfile_x

subroutine iotk_link_x(unit,name,file,binary,raw,create,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*),           intent(in)  :: file
  logical,      optional, intent(in)  :: binary
  logical,      optional, intent(in)  :: raw
  logical,      optional, intent(in)  :: create
  integer,      optional, intent(out) :: ierr
  logical :: lbinary,lraw,lcreate
  integer :: ierrl,iostat
  integer :: lunit,link_unit
  type(iotk_unit), pointer :: this_unit
  character(iotk_attlenx) :: attr
  character(iotk_fillenx) :: oldfile
  iostat = 0
  lbinary=.false.
  lraw   =.false.
  lcreate=.false.
  if(present(binary)) lbinary = binary
  if(present(raw))    lraw = raw
  if(present(create)) lcreate = create
  lunit = iotk_physical_unit(unit)
  call iotk_unit_get(lunit,pointer=this_unit,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_write_attr(attr,"iotk_link",trim(file),ierr=ierrl,first=.true.)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
    goto 1
  end if
  if(lbinary) then
    call iotk_write_attr(attr,"iotk_binary",lbinary,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
      goto 1
    end if
  end if
  if(lraw) then
    call iotk_write_attr(attr,"iotk_raw",lraw,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
      goto 1
    end if
  end if
  call iotk_write_begin(unit,name,attr,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_write_comment(unit,"This is a link to the file indicated in the iotk_link attribute",ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_write_end  (unit,name,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
    goto 1
  end if
  if(lcreate) then
    call iotk_free_unit(link_unit,ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
      goto 1
    end if
    inquire(unit=lunit,name=oldfile,iostat=iostat)
    if(iostat/=0) then
          call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error inquiring')
    call iotk_error_write(ierrl,"unit",lunit)
    call iotk_error_write(ierrl,"file",trim(oldfile))
    call iotk_error_write(ierrl,"iostat",iostat)
      goto 1
    end if
    call iotk_open_write(link_unit,file=trim(iotk_complete_filepath(file,oldfile)), &
                                 binary=lbinary,raw=lraw,skip_root=.true.,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
      goto 1
    end if
    call iotk_unit_parent(parent=lunit,son=link_unit,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_link",__FILE__,__LINE__)
      goto 1
    end if
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_link_x

subroutine iotk_open_write_x(unit,file,attr,binary,new,raw,root,skip_root,skip_head,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*), optional, intent(in)  :: file
  character(*), optional, intent(in)  :: attr
  logical,      optional, intent(in)  :: binary
  logical,      optional, intent(in)  :: new
  logical,      optional, intent(in)  :: raw
  character(*), optional, intent(in)  :: root
  logical,      optional, intent(in)  :: skip_root
  logical,      optional, intent(in)  :: skip_head
  integer,      optional, intent(out) :: ierr
! Opens a file properly
  integer :: iostat
  character(50) :: status,form
  character(iotk_namlenx) :: lroot
  character(iotk_attlenx) :: lattr
  integer :: ierrl
  logical :: lbinary,lraw,lnew,lskip_root,lskip_head
  ierrl = 0
  iostat = 0
  lroot = "Root"
  lraw = .false.
  lnew = .false.
  lbinary = .false.
  lskip_root = .false.
  lskip_head = .false.
  if(present(root)) lroot = root
  if(present(raw)) lraw=raw
  if(present(binary)) lbinary = binary
  if(present(new)) lnew = new
  if(present(skip_root)) lskip_root = skip_root
  if(lskip_root) lroot=""
  if(present(skip_head)) lskip_head = skip_head
  if(present(file)) then
    form = "formatted"
    if(lbinary) form = "unformatted"
    status = "unknown"
    if(lnew) status = "new"
    open(unit=unit,file=file,status=status,form=form,position="rewind",iostat=iostat,action="write")
    if(iostat/=0) then
          call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error opening file')
    call iotk_error_write(ierrl,"unit",unit)
    call iotk_error_write(ierrl,"file",file)
    call iotk_error_write(ierrl,"binary",lbinary)
    call iotk_error_write(ierrl,"new",lnew)
    call iotk_error_write(ierrl,"iostat",iostat)
      goto 1
    end if
  else
    call iotk_inquire(unit,binary=lbinary,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
      goto 1
    end if
  end if
  if(.not.lraw) then
    if(.not.lskip_head) then
      if(.not. lbinary) then
        write(unit,"(a)",iostat=iostat) '<?xml version="1.0"?>'
        if(iostat/=0) then
              call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing XML tag')
    call iotk_error_write(ierrl,"unit",unit)
    call iotk_error_write(ierrl,"iostat",iostat)
          goto 1
        end if
      end if
      call iotk_write_attr(lattr,"version",trim(iotk_version),first=.true.,ierr=ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing version attribute')
        goto 1
      end if
      call iotk_write_pi(unit,"iotk",lattr,ierr=ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing version tag')
        goto 1
      end if
      call iotk_write_attr(lattr,"binary",lbinary,first=.true.,ierr=ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing binary attribute')
        goto 1
      end if
      call iotk_write_pi(unit,"iotk",lattr,ierr=ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing binary tag')
        goto 1
      end if
      if(lbinary) then
        call iotk_write_attr(lattr,"binary_format",trim(iotk_binary_format),first=.true.,ierr=ierrl)
        if(ierrl/=0) then
              call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing binary_format attribute')
          goto 1
        end if
        call iotk_write_pi(unit,"iotk",lattr,ierr=ierrl)
        if(ierrl/=0) then
              call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing binary_format tag')
          goto 1
        end if
      end if
    end if
    if(.not.lskip_root) then
      lattr(1:1) = iotk_eos
      if(present(attr)) then
        call iotk_strcpy(lattr,attr,ierr=ierrl)
        if(ierrl/=0) then
              call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing attributes from the root tag')
          goto 1
        end if
      end if
      call iotk_write_begin(unit,lroot,attr=lattr,ierr=ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing the root tag')
        goto 1
      end if
    end if
  end if
  call iotk_unit_add(unit,root=lroot,raw=lraw,close_at_end=present(file),skip_root=lskip_root,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_open_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error adding the unit to the list')
    goto 1
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_open_write_x

recursive subroutine iotk_close_write_x(unit,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  integer,      optional, intent(out) :: ierr
! Closes a file properly
  character(iotk_namlenx) :: lroot
  logical :: binary,lraw,close_at_end,skip_root
  integer :: ierrl,iostat
  ierrl = 0
  iostat = 0
  inquire(unit=unit,name=lroot)
  call iotk_unit_get(unit,root=lroot,raw=lraw,close_at_end=close_at_end, &
                     skip_root=skip_root,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_close_write",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_unit_del(unit,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_close_write",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_inquire(unit,binary,ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_close_write",__FILE__,__LINE__)
    goto 1
  end if
  if(.not.lraw) then
    if(.not.skip_root) then
      call iotk_write_end(unit,lroot,ierr=ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_close_write",__FILE__,__LINE__)
        goto 1
      end if
    end if
  end if
  if(close_at_end) then
    if(.not.binary) then
      write(unit,*,iostat=iostat)
      if(iostat/=0) then
            call iotk_error_issue(ierrl,"iotk_close_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'unit')
    call iotk_error_write(ierrl,"iostat",iostat)
        goto 1
      end if
    end if
    close(unit,iostat=iostat)
    if(iostat/=0) then
          call iotk_error_issue(ierrl,"iotk_close_write",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'unit')
    call iotk_error_write(ierrl,"iostat",iostat)
      goto 1
    end if
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_close_write_x


subroutine iotk_open_read_x(unit,file,attr,binary,raw,root,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*), optional, intent(in)  :: file
  logical,      optional, intent(in)  :: binary
  logical,      optional, intent(in)  :: raw
  character(*), optional, intent(out) :: attr
  character(*), optional, intent(out) :: root
  integer,      optional, intent(out) :: ierr
  character(50)           :: status,form
  character(iotk_attlenx) :: lattr
  character(iotk_taglenx) :: tag
  character(iotk_namlenx) :: lroot
  integer                 :: ierrl,control,iostat
  logical                 :: lbinary,lraw
  ierrl = 0
  iostat = 0
  lbinary=.false.
  lraw=.false.
  lroot = " "
  lattr(1:1) = iotk_eos
  if(present(binary)) lbinary = binary
  if(present(raw)) lraw=raw
  if(present(file)) then
    form = "formatted"
    if(lbinary) form = "unformatted"
    open(unit=unit,file=file,status="old",form=form,position="rewind",iostat=iostat,action="read")
    if(iostat/=0) then
          call iotk_error_issue(ierrl,"iotk_open_read",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'unit')
    call iotk_error_write(ierrl,"file",trim(file))
    call iotk_error_write(ierrl,"binary",lbinary)
    call iotk_error_write(ierrl,"iostat",iostat)
      goto 1
    end if
  else
    call iotk_inquire(unit,binary=lbinary,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_open_read",__FILE__,__LINE__)
      goto 1
    end if
  end if
  if(.not.lraw) then
    do
      call iotk_scan_tag(unit,+1,control,tag,lbinary,ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_open_read",__FILE__,__LINE__)
        goto 1
      end if
      select case(control)
      case(1)
        call iotk_tag_parse(tag,lroot,lattr,ierrl)
        if(ierrl/=0) then
              call iotk_error_issue(ierrl,"iotk_open_read",__FILE__,__LINE__)
          goto 1
        end if
        exit
      case(2:3)
            call iotk_error_issue(ierrl,"iotk_open_read",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'End or empty tag at the beginning of a file')
    call iotk_error_write(ierrl,"unit",unit)
    call iotk_error_write(ierrl,"file",trim(file))
    call iotk_error_write(ierrl,"binary",lbinary)
    call iotk_error_write(ierrl,"iostat",iostat)
        goto 1
      case(5)
        call iotk_tag_parse(tag,lroot,lattr,ierrl)
        if(ierrl/=0) then
              call iotk_error_issue(ierrl,"iotk_open_read",__FILE__,__LINE__)
          goto 1
        end if
        if(lroot=="iotk") then
          call check_iotk_attr(unit,lattr,ierrl)
          if(ierrl/=0) then
                call iotk_error_issue(ierrl,"iotk_open_read",__FILE__,__LINE__)
            goto 1
          end if
        end if
      end select
    end do
  end if
  if(present(root)) root = lroot
  if(present(attr)) call iotk_strcpy(attr,lattr,ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_open_read",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_unit_add(unit,root=lroot,raw=lraw,close_at_end=present(file),skip_root=.false.,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_open_read",__FILE__,__LINE__)
    goto 1
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_open_read_x

subroutine iotk_close_read_x(unit,ierr) 
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: lroot
  integer                 :: ierrl
  logical :: close_at_end 
  logical :: lraw
  integer :: iostat
  ierrl = 0
  iostat = 0
  call iotk_unit_get(unit,root=lroot,raw=lraw,close_at_end=close_at_end,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_close_read",__FILE__,__LINE__)
    goto 1
  end if
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_close_read",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_unit_del(unit,ierr=ierrl)
  if(.not.lraw) then      
    call iotk_scan_end(unit,lroot,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_close_read",__FILE__,__LINE__)
      goto 1
    end if
  end if
  if(close_at_end) then
    close(unit,iostat=iostat)
    if(iostat/=0) then
          call iotk_error_issue(ierrl,"iotk_close_read",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'unit')
    call iotk_error_write(ierrl,"iostat",iostat)
      goto 1
    end if
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_close_read_x


subroutine iotk_write_begin_x(unit,name,attr,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(in)  :: attr
  integer,      optional, intent(out) :: ierr
  character(iotk_taglenx) :: tag
  character(iotk_attlenx) :: attrl
  character(iotk_fillenx) :: oldfile
  type(iotk_unit), pointer :: this_unit
  logical :: binary,raw
  integer :: ierrl,lunit,link_unit,iostat
  ierrl = 0
  iostat = 0
  lunit = iotk_physical_unit(unit)
  ierrl=0
  call iotk_unit_get(lunit,raw=raw,pointer=this_unit,ierr=ierrl)
  call iotk_error_clear(ierrl)
  if(.not.iotk_check_name(name)) then
        call iotk_error_issue(ierrl,"iotk_write_begin",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Wrong tag name')
    call iotk_error_write(ierrl,"name",name)
    goto 1
  end if
  attrl(1:1)=iotk_eos
  if(present(attr)) then
    call iotk_strcpy(attrl,attr,ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_write_begin",__FILE__,__LINE__)
      goto 1
    end if
  end if
  if(raw) goto 1
  call iotk_strcpy(tag,trim(name),ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_begin",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_strcat(tag,attrl,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_begin",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_inquire(lunit,binary=binary,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_begin",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_write_tag(lunit,1,tag,binary,ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_begin",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error writing tag')
    call iotk_error_write(ierrl,"name",name)
    goto 1
  end if
1 continue
  if(ierrl==0 .and. associated(this_unit)) then
    this_unit%level = this_unit%level + 1
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_write_begin_x
    
subroutine iotk_write_end_x(unit,name,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  integer,      optional, intent(out) :: ierr
  character(iotk_taglenx) :: tag
  logical :: binary,raw
  integer :: ierrl,lunit
  type(iotk_unit), pointer :: this_unit
  ierrl = 0
  lunit = iotk_physical_unit(unit)
  ierrl=0
  call iotk_unit_get(lunit,ierr=ierrl,pointer=this_unit,raw=raw)
  call iotk_error_clear(ierrl)
  if(.not.iotk_check_name(name)) then
        call iotk_error_issue(ierrl,"iotk_write_end",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Wrong tag name')
    call iotk_error_write(ierrl,"name",trim(name))
    goto 1
  end if
  if(raw) goto 2
  tag = trim(name)//iotk_eos
  call iotk_inquire(lunit,binary=binary,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_end",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_write_tag(lunit,2,tag,binary,ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_end",__FILE__,__LINE__)
    goto 1
  end if
2 continue
  if(ierrl==0 .and. associated(this_unit)) then
    this_unit%level = this_unit%level - 1
  end if
  if(associated(this_unit) .and. unit/=lunit) then
    if(associated(this_unit%parent) .and. this_unit%level == 0 .and. this_unit%skip_root) then
      call iotk_close_write(lunit,ierr=ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_write_end",__FILE__,__LINE__)
        goto 1
      end if
      lunit = iotk_physical_unit(unit)
      call iotk_unit_get(lunit,raw=raw,ierr=ierrl,pointer=this_unit)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_write_end",__FILE__,__LINE__)
        goto 1
      end if
    end if
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_write_end_x
    
subroutine iotk_write_pi_x(unit,name,attr,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(in)  :: attr
  integer,      optional, intent(out) :: ierr
  character(iotk_taglenx) :: tag
  character(iotk_attlenx) :: attrl
  logical :: binary,raw
  integer :: ierrl,lunit
  ierrl = 0
  lunit = iotk_physical_unit(unit)
  ierrl=0
  call iotk_unit_get(lunit,raw=raw,ierr=ierrl)
  call iotk_error_clear(ierrl)
  if(raw) goto 1
  if(.not.iotk_check_name(name)) then
        call iotk_error_issue(ierrl,"iotk_write_pi",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Wrong tag name')
    call iotk_error_write(ierrl,"name",trim(name))
    goto 1
  end if
  attrl(1:1)=iotk_eos
  if(present(attr)) then
    call iotk_strcpy(attrl,attr,ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_write_pi",__FILE__,__LINE__)
      goto 1
    end if
  end if
  call iotk_strcpy(tag,trim(name),ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_pi",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_strcat(tag,attrl,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_pi",__FILE__,__LINE__)
    goto 1 
  end if
  call iotk_inquire(lunit,binary=binary,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_pi",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_write_tag(lunit,5,tag,binary,ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_pi",__FILE__,__LINE__)
    goto 1
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_write_pi_x

subroutine iotk_write_comment_x(unit,text,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: text
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,lunit
  integer :: taglen
  logical :: binary,raw
  character(iotk_taglenx) :: tag
  ierrl = 0
  lunit = iotk_physical_unit(unit)
  ierrl=0
  call iotk_unit_get(lunit,raw=raw,ierr=ierrl)
  call iotk_error_clear(ierrl)
  if(raw) goto 1
  call iotk_deescape(tag,text)
  call iotk_inquire(lunit,binary=binary,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_comment",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_write_tag(lunit,4,tag,binary,ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_comment",__FILE__,__LINE__)
    goto 1
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_write_comment_x

subroutine iotk_write_empty_x(unit,name,attr,ierr)
  use iotk_base
  use iotk_interface
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(in)  :: attr
  integer,      optional, intent(out) :: ierr
  character(iotk_taglenx) :: tag
  logical :: binary,raw
  integer :: ierrl,lunit
  ierrl = 0
  lunit = iotk_physical_unit(unit)
  call iotk_unit_get(lunit,raw=raw,ierr=ierrl)
  call iotk_error_clear(ierrl)
  if(raw) goto 1
  if(.not.iotk_check_name(name)) then
        call iotk_error_issue(ierrl,"iotk_write_empty",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Wrong tag name')
    call iotk_error_write(ierrl,"name",trim(name))
    goto 1
  end if
  if(present(attr)) then
    tag = trim(name)//trim(attr(1:iotk_strlen(attr)))//iotk_eos
  else
    tag = trim(name)//iotk_eos
  end if
  call iotk_inquire(lunit,binary=binary,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_empty",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_write_tag(lunit,3,tag,binary,ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_write_empty",__FILE__,__LINE__)
    goto 1
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_write_empty_x

recursive subroutine iotk_scan_begin_x(unit,name,attr,found,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(out) :: attr
  logical,      optional, intent(out) :: found
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: namel
  character(iotk_attlenx) :: attrl
  character(iotk_vallenx) :: link
  logical :: link_binary,link_raw
  integer :: link_unit
  logical :: binary
  integer :: ierrl,iostat
  logical :: link_found
  logical :: raw
  type(iotk_unit), pointer :: this_unit
  integer :: lunit
  character(iotk_fillenx) :: oldfile
  namel = name
  ierrl = 0
  iostat = 0
  lunit = iotk_physical_unit(unit)
  call iotk_unit_get(lunit,raw=raw,pointer=this_unit,ierr=ierrl)
  call iotk_error_clear(ierrl)
  if(raw) goto 1
  call iotk_inquire(lunit,binary=binary,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_scan(lunit, 1,1,namel,attrl,binary,ierrl)
  if(ierrl>0) then
        call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
    goto 1
  end if
  if(ierrl/=0)  then
    call iotk_error_clear(ierrl)
    call iotk_scan(lunit,-1,1,namel,attrl,binary,ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
      goto 1
    end if
  end if
  call iotk_scan_attr(attrl,"iotk_link",link,found=link_found,ierr=ierrl)
  if(ierrl>0) then
        call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_error_clear(ierrl)
  if(link_found) then
    call iotk_scan_attr(attrl,"iotk_binary",link_binary,default=.false.,ierr=ierrl)
    if(ierrl>0) then
          call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
      goto 1
    end if
    call iotk_error_clear(ierrl)
    call iotk_scan_attr(attrl,"iotk_raw",link_raw,default=.false.,ierr=ierrl)
    if(ierrl>0) then
          call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
      goto 1
    end if
    call iotk_error_clear(ierrl)
    call iotk_free_unit(link_unit,ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
      goto 1
    end if
    inquire(unit=lunit,name=oldfile,iostat=iostat)
    if(iostat/=0) then
          call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
      goto 1
    end if
    call iotk_open_read(link_unit,file=trim(iotk_complete_filepath(link,oldfile)),attr=attrl, &
      binary=link_binary,raw=link_raw,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
      goto 1
    end if
    call iotk_unit_parent(parent=lunit,son=link_unit,ierr=ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
      goto 1
    end if
  end if
  if(present(attr)) call iotk_strcpy(attr,attrl,ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_scan_begin",__FILE__,__LINE__)
    goto 1
  end if
1 continue
  if(ierrl==0 .and. associated(this_unit)) then
    this_unit%level = this_unit%level + 1
!write(0,*) "LEVEL=",this_unit%level,"incrementato"
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. .not.present(found)) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_scan_begin_x

recursive subroutine iotk_scan_end_x(unit,name,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: namel
  logical :: binary,raw
  character(iotk_attlenx) :: attrl
  integer :: ierrl
  integer :: lunit
  type(iotk_unit), pointer :: this_unit
  namel = name
  ierrl = 0
  lunit = iotk_physical_unit(unit)
  call iotk_unit_get(lunit,raw=raw,ierr=ierrl,pointer=this_unit)
  call iotk_error_clear(ierrl)
  if(associated(this_unit)) then
    if(associated(this_unit%parent) .and. this_unit%level == 0) then
      this_unit => this_unit%parent
      call iotk_close_read(lunit,ierr=ierrl)
      if(ierrl/=0) goto 1
      lunit = iotk_physical_unit(unit)
      call iotk_unit_get(lunit,raw=raw,ierr=ierrl,pointer=this_unit)
      call iotk_error_clear(ierrl)
    end if
  end if
  if(raw) goto 1
  call iotk_inquire(lunit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_scan(lunit,1,2,namel,attrl,binary,ierrl)
  if(ierrl/=0) goto 1
  if(iotk_strlen(attrl)/=0) then
        call iotk_error_issue(ierrl,"iotk_scan_end",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'An end tag should not contain attributes')
    call iotk_error_write(ierrl,"name",trim(name))
    call iotk_error_write(ierrl,"attr",attrl(1:iotk_strlen(attrl)))
    goto 1
  end if
  if(associated(this_unit)) this_unit%level = this_unit%level - 1
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_scan_end_x

subroutine iotk_scan_pi_x(unit,name,attr,found,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(out) :: attr
  logical,      optional, intent(out) :: found
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: namel
  character(iotk_attlenx) :: attrl
  logical :: binary,raw
  integer :: ierrl,lunit
  namel = name
  ierrl = 0
  lunit = iotk_physical_unit(unit)
  call iotk_unit_get(lunit,raw=raw,ierr=ierrl)
  call iotk_error_clear(ierrl)
  if(raw) goto 1
  call iotk_inquire(lunit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_scan(lunit,1,5,namel,attrl,binary,ierrl)
  if(ierrl>0) goto 1
  if(ierrl<0) then
    call iotk_error_clear(ierrl)
    call iotk_scan(lunit,-1,5,namel,attrl,binary,ierrl)
  end if
  if(ierrl/=0) goto 1
  if(present(attr)) call iotk_strcpy(attr,attrl,ierrl)
  if(ierrl/=0) goto 1
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. .not.present(found)) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_scan_pi_x

subroutine iotk_scan_empty_x(unit,name,attr,found,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(out) :: attr
  logical,      optional, intent(out) :: found
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: namel
  character(iotk_attlenx) :: attrl
  logical :: binary,raw
  integer :: ierrl,lunit
  namel = name
  ierrl = 0
  lunit = iotk_physical_unit(unit)
  call iotk_unit_get(lunit,raw=raw,ierr=ierrl)
  call iotk_error_clear(ierrl)
  if(raw) goto 1
  call iotk_inquire(lunit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_scan(lunit,1,3,namel,attrl,binary,ierrl)
  if(ierrl>0) goto 1
  if(ierrl<0) then
    call iotk_error_clear(ierrl)
    call iotk_scan(lunit,-1,3,namel,attrl,binary,ierrl)
  end if
  if(ierrl/=0) goto 1
  if(present(attr)) call iotk_strcpy(attr,attrl,ierrl)
  if(ierrl/=0) goto 1
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. .not.present(found)) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_scan_empty_x

subroutine iotk_free_unit_x(unit,ierr)
  use iotk_base
  use iotk_interface
  implicit none
! This subroutine sets 'unit' to the number of
! an I/O unit which is free (i.e. not already opened).
! The search is carried out starting from unit
! 'unitmin' in a range of 'nsearch' units.
! The starting unit for the search is increased at each
! call, so that a number of subsequent ask can be done
! obtaining different units.
  integer,           intent(out) :: unit
  integer, optional, intent(out) :: ierr
  integer, save :: offset = 0
  logical       :: opened,exist
  integer       :: isearch,nsearch,unitmin
  integer       :: ierrl
  integer       :: iostat
  iostat = 0
  unitmin = iotk_unitmin
  nsearch = iotk_unitmax - iotk_unitmin + 1
  ierrl = 0 
  do isearch=0,nsearch-1
    unit = modulo(isearch+offset,nsearch) + unitmin
    inquire(unit=unit,opened=opened,exist=exist,iostat=iostat)
    if((.not.opened .and. exist) .or. iostat/=0) exit
  end do
  if(iostat/=0) then
        call iotk_error_issue(ierrl,"iotk_free_unit",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Error inquiring')
    call iotk_error_write(ierrl,"unit",unit)
    call iotk_error_write(ierrl,"iostat",iostat)
    goto 1
  end if 
  if(isearch>=nsearch) then
        call iotk_error_issue(ierrl,"iotk_free_unit",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'There are no units left')
    goto 1
  end if 
1 continue
  offset = modulo(unit - unitmin + 1,nsearch)
  if(present(ierr)) then 
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_free_unit_x

function iotk_physical_unit_x(unit)
  use iotk_base
  use iotk_interface
  implicit none
  integer, intent(in) :: unit
  integer :: iotk_physical_unit_x
  integer :: ierrl
  type(iotk_unit), pointer :: this
  ierrl = 0
  iotk_physical_unit_X = unit
  if(.not. iotk_units_init) then
    iotk_units_init = .true.
    nullify(iotk_units)
  end if
  call iotk_unit_get(unit,pointer=this,ierr=ierrl)
  if(ierrl/=0) then
    call iotk_error_clear(ierrl)
    return
  end if
  do
    if(.not. associated(this%son)) exit
    this => this%son
  end do
  iotk_physical_unit_x = this%unit
end function iotk_physical_unit_x

subroutine iotk_unit_print_x(unit)
  use iotk_base
  use iotk_interface
  implicit none 
  integer, intent(in) :: unit
  type (iotk_unit), pointer :: this
  this => iotk_units
  write(unit,"(a)") "IOTK units"
  do
    if(.not. associated(this)) exit
    write(unit,"(a,i8)") "Unit :",this%unit
    write(unit,"(a,a,a,i8)") "Root :",trim(this%root),"Level:",this%level
    if(associated(this%son)) then
      write(unit,"(a,i8)") "Son :",this%son%unit
    end if
    if(associated(this%parent)) then
      write(unit,"(a,i8)") "Parent :",this%parent%unit
    end if
    this => this%next
  end do
  write(unit,"(a)") "end IOTK units"
end subroutine iotk_unit_print_x

subroutine iotk_unit_add_x(unit,root,raw,close_at_end,skip_root,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,           intent(in)  :: unit
  character(*),      intent(in)  :: root
  logical,           intent(in)  :: raw
  logical,           intent(in)  :: close_at_end
  logical,           intent(in)  :: skip_root
  integer,           intent(out) :: ierr
  type (iotk_unit), pointer :: this
  ierr = 0
  if(.not. iotk_units_init) then
    iotk_units_init = .true.
    nullify(iotk_units)
  end if 
  this => iotk_units
  do
    if(.not.associated(this)) exit
    if(this%unit == unit) then
          call iotk_error_issue(ierr,"iotk_unit_add",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'unit')
      return
    end if
    this => this%next
  end do
  allocate(this)
  this%unit      = unit
  this%root      = root
  this%skip_root = skip_root
  this%raw       = raw
  this%next  => iotk_units
  nullify(this%son)
  nullify(this%parent)
  this%level=0
  this%close_at_end=close_at_end
  iotk_units => this
end subroutine iotk_unit_add_x

subroutine iotk_inquire_x(unit,binary,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,           intent(in)  :: unit
  logical,           intent(out) :: binary
  integer,           intent(out) :: ierr
  character(50) :: form,access,pad,blank
  logical :: opened
  integer :: iostat
  iostat = 0
  ierr = 0
  inquire(unit=unit,form=form,iostat=iostat,access=access,pad=pad,blank=blank,opened=opened)
  if(iostat/=0) then
        call iotk_error_issue(ierr,"iotk_inquire",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'Error inquiring')
    return
  end if
  if(opened .and. iotk_toupper(form)=="UNFORMATTED") then
    binary = .true.
  else
    binary = .false.
  end if
  if(opened .and. iotk_toupper(access)/="SEQUENTIAL") then
        call iotk_error_issue(ierr,"iotk_inquire",__FILE__,__LINE__)
    return
  end if
  if(.not. binary) then
    if(opened .and. iotk_toupper(blank)/="NULL") then
          call iotk_error_issue(ierr,"iotk_inquire",__FILE__,__LINE__)
      return
    end if
    if(opened .and. iotk_toupper(pad)  /="YES") then
          call iotk_error_issue(ierr,"iotk_inquire",__FILE__,__LINE__)
      return
    end if
  end if
end subroutine iotk_inquire_x

subroutine iotk_copy_tag_x(source,dest,maxsize,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,           intent(in)  :: source
  integer,           intent(in)  :: dest
  integer, optional, intent(in)  :: maxsize
  integer, optional, intent(out) :: ierr
  logical :: source_binary,dest_binary
  integer :: ierrl,control,maxsizel
  character(iotk_taglenx) :: tag
  character(iotk_namlenx) :: name,root
  character(iotk_attlenx) :: attr
  character(iotk_vallenx) :: type
  integer :: taglen           
  ierrl = 0         
  maxsizel = -1     
  if(present(maxsize)) maxsizel = maxsize 
  call iotk_inquire(source,binary=source_binary,ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_copy_tag",__FILE__,__LINE__)
    goto 1
  end if
  call iotk_inquire(dest  ,binary=dest_binary,  ierr=ierrl)
  if(ierrl/=0) then
        call iotk_error_issue(ierrl,"iotk_copy_tag",__FILE__,__LINE__)            
    goto 1
  end if
  call iotk_unit_get(source,root=root,ierr=ierrl)
  if(ierrl/=0) then 
        call iotk_error_issue(ierrl,"iotk_copy_tag",__FILE__,__LINE__)  
    goto 1
  end if
  do
    call iotk_scan_tag(source,+1,control,tag,source_binary,ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_copy_tag",__FILE__,__LINE__)
      goto 1
    end if
    call iotk_tag_parse(tag,name,attr,ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_copy_tag",__FILE__,__LINE__)
      goto 1
    end if
    if(name == root) then
      call iotk_scan_tag(source,-1,control,tag,source_binary,ierrl)
        if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_copy_tag",__FILE__,__LINE__)
        goto 1
      end if
    end if
    call iotk_scan_attr(attr,"type",type,ierr=ierrl,eos=.true.,default=" ")
    if(ierrl<0) call iotk_error_clear(ierrl)
    if(ierrl/=0) then
          call iotk_error_issue(ierrl,"iotk_copy_tag",__FILE__,__LINE__)
      goto 1
    end if
    if((iotk_strcomp(type,"real") .or. iotk_strcomp(type,"integer") .or. iotk_strcomp(type,"logical") &
                                  .or. iotk_strcomp(type,"character") .or. iotk_strcomp(type,"complex")) .and. control==1) then
      call iotk_copy_dat(source,dest,source_binary,dest_binary,name,attr,maxsize=maxsizel,ierr=ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_copy_tag",__FILE__,__LINE__)
        goto 1
      end if
      call iotk_scan_tag(source,+1,control,tag,source_binary,ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_copy_tag",__FILE__,__LINE__)
        goto 1
      end if
    else
      call iotk_write_tag(dest,control,tag,dest_binary,ierrl)
      if(ierrl/=0) then
            call iotk_error_issue(ierrl,"iotk_copy_tag",__FILE__,__LINE__)
        goto 1
      end if
    end if
  end do
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_copy_tag_x

subroutine iotk_unit_del_x(unit,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer, intent(in)  :: unit
  integer, intent(out) :: ierr
  type (iotk_unit), pointer :: this,prev
  ierr = 0
  if(.not. iotk_units_init) then
    iotk_units_init = .true.
    nullify(iotk_units)
  end if
  nullify(prev)
  this => iotk_units
  do
    if(.not.associated(this)) then
          call iotk_error_issue(ierr,"iotk_unit_del",__FILE__,__LINE__)
      return
    end if
    if(this%unit == unit) exit
    prev => this
    this => this%next
  end do
  if(associated(this%son)) then
        call iotk_error_issue(ierr,"iotk_unit_del",__FILE__,__LINE__)
    return
  end if
  if(associated(this%parent)) then
  end if
  if(associated(this%parent)) nullify(this%parent%son)
  if(associated(prev)) then
    prev%next  => this%next
  else
    iotk_units => this%next
  end if
  deallocate(this)
end subroutine iotk_unit_del_x

subroutine iotk_unit_parent_x(parent,son,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer, intent(in) :: parent,son
  integer, intent(out) :: ierr
  type(iotk_unit), pointer :: this_parent,this_son
  ierr = 0
  call iotk_unit_get(parent,pointer=this_parent,ierr=ierr)
  if(ierr/=0) then
        call iotk_error_issue(ierr,"iotk_unit_parent",__FILE__,__LINE__)
    return
  end if
  call iotk_unit_get(son,pointer=this_son,ierr=ierr)
  if(ierr/=0) then
        call iotk_error_issue(ierr,"iotk_unit_parent",__FILE__,__LINE__)
    return
  end if
  if(associated(this_parent%son)) then
        call iotk_error_issue(ierr,"iotk_unit_parent",__FILE__,__LINE__)
    return
  end if
  if(associated(this_son%parent)) then
        call iotk_error_issue(ierr,"iotk_unit_parent",__FILE__,__LINE__)
    return
  end if
  this_parent%son => this_son
  this_son%parent => this_parent
end subroutine iotk_unit_parent_x

subroutine iotk_unit_get_x(unit,root,raw,son,parent,level,pointer,close_at_end,skip_root,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                intent(in)  :: unit
  character(*), optional, intent(out) :: root
  integer,      optional, intent(out) :: ierr
  integer,      optional, intent(out) :: level
  logical,      optional, intent(out) :: close_at_end
  logical,      optional, intent(out) :: skip_root
  type(iotk_unit), optional, pointer :: pointer
  type(iotk_unit), optional, pointer :: son
  type(iotk_unit), optional, pointer :: parent
  logical,      optional, intent(out) :: raw
  type (iotk_unit), pointer :: this
  integer :: ierrl
  ierrl = 0
  if(present(root)) root = ""
  if(present(raw))  raw  = .false.
  if(present(pointer)) nullify(pointer)
  if(present(son)) nullify(son)
  if(present(parent)) nullify(parent)
  if(present(level)) level = 0
  if(present(close_at_end)) close_at_end = .false.
  if(present(skip_root)) skip_root = .false.
  if(.not. iotk_units_init) then
    iotk_units_init = .true.
    nullify(iotk_units)
  end if
  this => iotk_units
  do
    if(.not.associated(this)) then
          call iotk_error_issue(ierrl,"iotk_unit_get",__FILE__,__LINE__)
      goto 1
    end if
    if(this%unit == unit) exit
    this => this%next
  end do
  if(present(root)) root = this%root
  if(present(raw))  raw  = this%raw
  if(present(pointer)) pointer => this
  if(present(son)) son => this%son
  if(present(parent)) parent => this%parent
  if(present(level)) level = this%level
  if(present(close_at_end)) close_at_end = this%close_at_end
  if(present(skip_root)) skip_root = this%skip_root
1 continue         
  if(present(ierr)) then
    ierr = ierrl   
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_unit_get_x

subroutine iotk_parse_dat_x(attr,type,ikind,isize,ilen,fmt,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  character(*), intent(in)  :: attr
  character(*), intent(out) :: type
  integer,      intent(out) :: ikind
  integer,      intent(out) :: isize
  integer,      intent(out) :: ilen
  character(*), intent(out) :: fmt
  integer,      intent(out) :: ierr
  character(iotk_vallenx) :: typename
  integer :: typelen
  ierr = 0
  call iotk_scan_attr(attr,"type",typename,ierr=ierr,eos=.true.,default=iotk_eos)
  if(ierr<0) call iotk_error_clear(ierr)
  if(ierr/=0) then
        call iotk_error_issue(ierr,"iotk_parse_dat",__FILE__,__LINE__)
    return
  end if
  typelen = iotk_strlen(typename)
  type = iotk_toupper(typename)
  call iotk_scan_attr(attr,"kind",ikind,ierr=ierr,default=-1)
  if(ierr<0) call iotk_error_clear(ierr)
  if(ierr/=0) then
        call iotk_error_issue(ierr,"iotk_parse_dat",__FILE__,__LINE__)
    return
  end if
  call iotk_scan_attr(attr,"size",isize,ierr=ierr,default=-1)
  if(ierr<0) call iotk_error_clear(ierr)
  if(ierr/=0) then
        call iotk_error_issue(ierr,"iotk_parse_dat",__FILE__,__LINE__)
    return
  end if
  call iotk_scan_attr(attr,"len", ilen, ierr=ierr,default=-1)
  if(ierr<0) call iotk_error_clear(ierr)
  if(ierr/=0) then
        call iotk_error_issue(ierr,"iotk_parse_dat",__FILE__,__LINE__)
    return
  end if
  call iotk_scan_attr(attr,"fmt", fmt, ierr=ierr,eos=.true.,default="!")
  if(ierr<0) call iotk_error_clear(ierr)
  if(ierr/=0) then
        call iotk_error_issue(ierr,"iotk_parse_dat",__FILE__,__LINE__)
    return
  end if
end subroutine iotk_parse_dat_x

subroutine iotk_set_options_x(unitmin,unitmax,getline_buffer,error_warn_overflow,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer, optional, intent(in) :: unitmin
  integer, optional, intent(in) :: unitmax
  integer, optional, intent(in) :: getline_buffer
  logical, optional, intent(in) :: error_warn_overflow
  integer, optional, intent(out):: ierr
  integer :: ierrl
  ierrl = 0
  if(present(error_warn_overflow)) then
    iotk_error_warn_overflow = error_warn_overflow
  end if
  if(present(unitmin)) then
    if(unitmin<0) then
          call iotk_error_issue(ierrl,"iotk_set_options",__FILE__,__LINE__)
      goto 1 
    end if
    iotk_unitmin = unitmin 
  end if
  if(present(unitmax)) then
    if(unitmax<iotk_unitmin) then
          call iotk_error_issue(ierrl,"iotk_set_options",__FILE__,__LINE__)
      goto 1
    end if
    iotk_unitmax = unitmax
  end if
  if(present(getline_buffer)) then
    if(getline_buffer<1) then
          call iotk_error_issue(ierrl,"iotk_set_options",__FILE__,__LINE__)
      goto 1
    end if
    iotk_getline_buffer = getline_buffer
  end if
1 continue 
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
end subroutine iotk_set_options_x

subroutine iotk_get_options_x(unitmin,unitmax,getline_buffer,error_warn_overflow)
  use iotk_base
  use iotk_interface
  implicit none
  integer, optional, intent(out):: unitmin
  integer, optional, intent(out):: unitmax
  integer, optional, intent(out):: getline_buffer
  logical, optional, intent(out):: error_warn_overflow
  if(present(unitmin)) unitmin = iotk_unitmin
  if(present(unitmax)) unitmax = iotk_unitmax
  if(present(unitmax)) getline_buffer = iotk_getline_buffer
  if(present(error_warn_overflow)) error_warn_overflow = iotk_error_warn_overflow
end subroutine iotk_get_options_x

function iotk_version_number_x(version,iswitch)
  use iotk_base
  use iotk_interface
  implicit none 
  character(*), intent(in) :: version
  integer,      intent(in) :: iswitch
! Extract version numbers from version string
! iswitch = 1 (major), 2 (minor) or 3 (patch)
  integer :: iotk_version_number_x
  integer :: iostat
  integer :: pos1,pos2,itmp
  iotk_version_number_x = -1
  pos1 = scan(version,".")
  if(pos1==0) return
  pos2 = scan(version(pos1+1:),".") + pos1
  if(pos2<=pos1) return
  iostat = 0
  select case(iswitch)
  case(1)
    read(version(1:pos1-1),"(i10)",iostat=iostat) itmp
  case(2)
    read(version(pos1+1:pos2-1),"(i10)",iostat=iostat) itmp
  case(3)
    read(version(pos2+1:),"(i10)",iostat=iostat) itmp
  end select
  if(iostat/=0) return
  iotk_version_number_x = itmp
end function iotk_version_number_x


subroutine iotk_print_kinds_x
  use iotk_base
  use iotk_interface
  implicit none
  character(100) :: string
#ifdef __IOTK_LOGICAL1
  string = "logical(kind="//trim(iotk_itoa(__IOTK_LOGICAL1))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_LOGICAL2
  string = "logical(kind="//trim(iotk_itoa(__IOTK_LOGICAL2))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_LOGICAL3
  string = "logical(kind="//trim(iotk_itoa(__IOTK_LOGICAL3))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_LOGICAL4
  string = "logical(kind="//trim(iotk_itoa(__IOTK_LOGICAL4))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_INTEGER1
  string = "integer(kind="//trim(iotk_itoa(__IOTK_INTEGER1))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_INTEGER2
  string = "integer(kind="//trim(iotk_itoa(__IOTK_INTEGER2))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_INTEGER3
  string = "integer(kind="//trim(iotk_itoa(__IOTK_INTEGER3))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_INTEGER4
  string = "integer(kind="//trim(iotk_itoa(__IOTK_INTEGER4))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_REAL1
  string = "real(kind="//trim(iotk_itoa(__IOTK_REAL1))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_REAL2
  string = "real(kind="//trim(iotk_itoa(__IOTK_REAL2))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_REAL3
  string = "real(kind="//trim(iotk_itoa(__IOTK_REAL3))//")"
  write(*,"(a)") trim(string)
#endif
#ifdef __IOTK_REAL4
  string = "real(kind="//trim(iotk_itoa(__IOTK_REAL4))//")"
  write(*,"(a)") trim(string)
#endif
  string = "character(kind="//trim(iotk_itoa(__IOTK_CHARACTER1))//")"
  write(*,"(a)") trim(string)
end subroutine iotk_print_kinds_x


subroutine iotk_copy_dat_aux_x(source,dest,source_binary,dest_binary,name,type,ikind,isize,ilen,fmt,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,      intent(in)  :: source
  integer,      intent(in)  :: dest
  logical,      intent(in)  :: source_binary
  logical,      intent(in)  :: dest_binary
  character(*), intent(in)  :: name
  character(*), intent(in)  :: type
  integer,      intent(in)  :: ikind
  integer,      intent(in)  :: isize
  integer,      intent(in)  :: ilen
  character(*), intent(in)  :: fmt
  integer,      intent(out) :: ierr
  
  logical  (kind=iotk_defkind_LOGICAL),           allocatable :: dat_lo(:)
  integer  (kind=iotk_defkind_INTEGER),           allocatable :: dat_in(:)
  real     (kind=iotk_defkind_REAL),              allocatable :: dat_re(:)
  complex  (kind=iotk_defkind_COMPLEX),           allocatable :: dat_co(:)
  character(kind=iotk_defkind_CHARACTER,len=ilen), allocatable :: dat_ch(:)
  
  ierr = 0
  select case(type(1:iotk_strlen(type)))
  case("LOGICAL")
    allocate(dat_lo(isize))
    call iotk_scan_dat_aux(source,dat_lo,ikind,ilen,fmt,ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat_aux",__FILE__,__LINE__)
      return
    end if
    call iotk_write_dat(dest,name,dat_lo,ierr=ierr,fmt=fmt)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat_aux",__FILE__,__LINE__)
      return
    end if
    deallocate(dat_lo)
  case("INTEGER")
    allocate(dat_in(isize))
    call iotk_scan_dat_aux(source,dat_in,ikind,ilen,fmt,ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat_aux",__FILE__,__LINE__)
      return
    end if
    call iotk_write_dat(dest,name,dat_in,ierr=ierr,fmt=fmt)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat_aux",__FILE__,__LINE__)
      return
    end if
    deallocate(dat_in)
  case("REAL")
    allocate(dat_re(isize))
    call iotk_scan_dat_aux(source,dat_re,ikind,ilen,fmt,ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat_aux",__FILE__,__LINE__)
      return
    end if
    call iotk_write_dat(dest,name,dat_re,ierr=ierr,fmt=fmt)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat_aux",__FILE__,__LINE__)
      return
    end if
    deallocate(dat_re)
  case("COMPLEX")
    allocate(dat_co(isize))
    call iotk_scan_dat_aux(source,dat_co,ikind,ilen,fmt,ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat_aux",__FILE__,__LINE__)
      return
    end if
    call iotk_write_dat(dest,name,dat_co,ierr=ierr,fmt=fmt)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat_aux",__FILE__,__LINE__)
      return
    end if
    deallocate(dat_co)
  case("CHARACTER")
    allocate(dat_ch(isize))
    call iotk_scan_dat_aux(source,dat_ch,ikind,ilen,fmt,ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat_aux",__FILE__,__LINE__)
      return
    end if
    call iotk_write_dat(dest,name,dat_ch,ierr=ierr,fmt=fmt)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat_aux",__FILE__,__LINE__)
      return
    end if
    deallocate(dat_ch)
  end select
end subroutine iotk_copy_dat_aux_x


subroutine iotk_copy_dat_x(source,dest,source_binary,dest_binary,name,attr,maxsize,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,      intent(in)  :: source
  integer,      intent(in)  :: dest
  logical,      intent(in)  :: source_binary
  logical,      intent(in)  :: dest_binary
  character(*), intent(in)  :: name
  character(*), intent(in)  :: attr
  integer,      intent(in)  :: maxsize
  integer,      intent(out) :: ierr
  character(9) :: type
  integer :: ikind,isize,ilen
  character(iotk_vallenx) :: fmt
  character(iotk_attlenx) :: attr1
  ierr = 0
  call iotk_parse_dat(attr,type,ikind,isize,ilen,fmt,ierr)
  if(ierr/=0) then
        call iotk_error_issue(ierr,"iotk_copy_dat",__FILE__,__LINE__)
    return
  end if
  if(iotk_strcomp(type,iotk_eos)) then
        call iotk_error_issue(ierr,"iotk_copy_dat",__FILE__,__LINE__)
    return
  end if
  if(isize==-1) then
        call iotk_error_issue(ierr,"iotk_copy_dat",__FILE__,__LINE__)
    return
  end if
  if(ilen==-1 .and. type=="CHARACTER") then
        call iotk_error_issue(ierr,"iotk_copy_dat",__FILE__,__LINE__)
    return
  end if
  if(isize<=maxsize .or. maxsize==-1 .or. dest_binary) then
    call iotk_copy_dat_aux(source,dest,source_binary,dest_binary,name,type,ikind,isize,ilen,fmt,ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat",__FILE__,__LINE__)
      return
    end if  
  else    
    call iotk_strcpy(attr1,attr,ierr=ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat",__FILE__,__LINE__)
      return
    end if
    call iotk_write_attr (attr1,"trunc",.true.,ierr=ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat",__FILE__,__LINE__)
      return
    end if
    call iotk_write_empty(dest,name,attr=attr1,ierr=ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_copy_dat",__FILE__,__LINE__)
      return
    end if
  end if
end subroutine iotk_copy_dat_x


subroutine iotk_write_tag_x(unit,control,tag,binary,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                   intent(in)  :: unit
  integer,                   intent(in)  :: control
  character(iotk_taglenx),   intent(in)  :: tag
  logical,                   intent(in)  :: binary
  integer,                   intent(out) :: ierr
  integer(iotk_header_kind) :: header,header2
  integer :: taglen
  integer :: iostat
  character(4) :: begin,end
  iostat = 0
  ierr = 0
  taglen = iotk_strlen(tag)
  if(binary) then
    header  = control + taglen*(iotk_ncontrol+1)
    header2 = 128     + taglen*(iotk_ncontrol+1)
    write(unit,iostat=iostat) header
    if(iostat/=0) then
          call iotk_error_issue(ierr,"iotk_write_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'error writing the header record')
    call iotk_error_write(ierr,"iostat",iostat)
    end if
    write(unit,iostat=iostat) header2,tag(1:taglen)
  else
    select case(control)
    case(1)
      begin = "<"
      end   = ">"
    case(2)
      begin = "</"
      end   = ">"
    case(3)
      begin = "<"
      end   = "/>"
    case(4)
      begin = "<!--"
      end   = "-->"
    case(5)
      begin = "<?"
      end   = "?>"
    end select
    write(unit,"(a)",iostat=iostat) trim(begin)//tag(1:taglen)//trim(end)
  end if
  if(iostat/=0) then
        call iotk_error_issue(ierr,"iotk_write_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'error writing')
    call iotk_error_write(ierr,"iostat",iostat)
  end if
end subroutine iotk_write_tag_x


subroutine check_iotk_attr_x(unit,attr,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                 intent(in)  :: unit
  character(iotk_attlenx), intent(in)  :: attr
  integer,                 intent(out) :: ierr
  character(iotk_vallenx) :: version,binary_format
  logical :: binary,rbinary
  ierr = 0
  call iotk_scan_attr(attr,"version",version,ierr=ierr)
  if(ierr>0) then
        call iotk_error_issue(ierr,"check_iotk_attr",__FILE__,__LINE__)
    return
  else if(ierr<0) then
    call iotk_error_clear(ierr)
  else
    if(iotk_version_number(version,1)<0 .or. iotk_version_number(version,2)<0 &
       .or. iotk_version_number(version,3)<0) then
          call iotk_error_issue(ierr,"check_iotk_attr",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'Problems reading file version')
      return
    end if
    if(iotk_version_number(version,1)> iotk_version_number(iotk_version,1) .or. &
       iotk_version_number(version,1)==iotk_version_number(iotk_version,1) .and. &
       iotk_version_number(version,2)> iotk_version_number(iotk_version,2)) then
          call iotk_error_issue(ierr,"check_iotk_attr",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'File version is newer than internal version')
      return
    end if
  end if
  call iotk_scan_attr(attr,"binary",rbinary,ierr=ierr)
  if(ierr>0) then
        call iotk_error_issue(ierr,"check_iotk_attr",__FILE__,__LINE__)
    return
  else if(ierr<0) then
    call iotk_error_clear(ierr)
  else
    call iotk_inquire(unit,binary,ierr=ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"check_iotk_attr",__FILE__,__LINE__)
      return
    end if
    if(rbinary .neqv. binary) then
          call iotk_error_issue(ierr,"check_iotk_attr",__FILE__,__LINE__)
      return
    end if
  end if
  call iotk_scan_attr(attr,"binary_format",binary_format,ierr=ierr)
  if(ierr>0) then
        call iotk_error_issue(ierr,"check_iotk_attr",__FILE__,__LINE__)
    return
  else if(ierr<0) then
    call iotk_error_clear(ierr)
  else
    if(binary_format/=iotk_binary_format .and. binary_format/="*" .and. iotk_binary_format/="*") then
          call iotk_error_issue(ierr,"check_iotk_attr",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'Binary format is not compatible')
      return
    end if
  end if
end subroutine check_iotk_attr_x

subroutine iotk_scan_tag_x(unit,direction,control,tag,binary,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                 intent(in)  :: unit
  integer,                 intent(in)  :: direction
  integer,                 intent(out) :: control
  character(iotk_taglenx), intent(out) :: tag
  logical,                 intent(in)  :: binary
  integer,                 intent(out) :: ierr

  integer(iotk_header_kind) :: header
  integer :: taglen,pos,pos1,res,length,iostat
  character(2) :: begin,end
  character(iotk_linlenx) :: line
  logical :: found
  ierr = 0
  iostat = 0
  tag  = " "
  if(binary) then
    found = .false.
    do
      if(direction<0) then
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'iostat')
          return
        end if
      end if
      read(unit,iostat=iostat) header
      if(iostat/=0) then
            call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'iostat')
        return
      end if
      control = modulo(header,iotk_ncontrol+1)
      if(control/=0 .and. control/=128) then
        found = .true.
        taglen  = modulo(header/(iotk_ncontrol+1),iotk_taglenx+1)
        read(unit,iostat=iostat) header,tag(1:taglen)
        if(iostat/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'iostat')
          return
        end if
        if(taglen<len(tag)) tag(taglen+1:taglen+1)=iotk_eos
      end if
      if(direction<0) then
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'iostat')
          return
        end if
      end if
      if(found) exit
    end do
    if(direction<0) then
      backspace(unit,iostat=iostat)
      if(iostat/=0) then
            call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'iostat')
        return
      end if
    end if
  else
! RISISTEMARE IN MODO CHE SI POSSA AVERE NELLA TAG ANCHE < e >
    if(direction>=0) then
      taglen = 0
      do
        call iotk_getline(unit,line,length,ierr)
        if(ierr/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
          return
        end if
        pos = scan(line(1:length),"<")
        if(pos/=0) exit
      end do
      do
        pos1 = scan(line(pos+1:length),">") + pos
        if(pos1/=pos) exit
        if(taglen+length-pos+1>len(tag)) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'Tag too long')
          return
        end if
        tag(taglen+1:taglen+1) = " "
        tag(taglen+2:taglen+length-pos+1) = line(pos+1:length)
        taglen = taglen+length-pos+1
        pos = 0
        call iotk_getline(unit,line,length,ierr)
        if(ierr/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)    
          return
        end if
      end do
      if(taglen+pos1-pos>len(tag)) then
            call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'Tag too long')
        return
      end if
      tag(taglen+1:taglen+1) = " "
      tag(taglen+2:taglen+pos1-pos) = line(pos+1:pos1-1)
      taglen =taglen+pos1-pos
      res = len_trim(line(1:length))-pos1 ! LA LUNGHEZZA E' TRIMMATA. IN QUESTO MODO SI VA A CAPO
                                          ! SE CI SONO SOLO SPAZI
      if(res>0) then
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'iostat')
          return
        end if
        call iotk_getline(unit,line,length,ierr)
        if(ierr/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
          return
        end if
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'iostat')
          return
        end if
        res = length-res
        read(unit,"(a)",iostat=iostat,advance='no') line(1:res)
        if(iostat/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'length')
    call iotk_error_write(ierr,"res",res)
    call iotk_error_write(ierr,"iostat",iostat)
          return
        end if
      end if
!      pos = verify(tag," ")
!      pos1 = len_trim(tag(1:taglen))
!      pos1 = taglen
       pos = 2
       pos1=taglen
    else
      call iotk_getline(unit,line,length,ierr)
      if(ierr/=0) then
            call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
        return
      end if
      res = length
!write(0,*) ">>>",res
      do
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
          return
        end if
        call iotk_getline(unit,line,length,ierr)
        if(ierr/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
          return
        end if
!write(0,*) ">>>%",length,res
        pos = length - res
        pos = scan(line(1:pos),">",back=.true.)
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
          return
        end if
        if(pos/=0) exit
        res = 0
      end do
      taglen=len(tag)+1
      do
        pos1 = scan(line(1:pos-1),"<",back=.true.)
        res = taglen
        if(pos1>0) exit
!CHECK
        tag(res-1:res-1) = " "
        tag(res-pos:res-2) = line(1:pos-1)
        taglen=taglen-pos
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
          return
        end if
        call iotk_getline(unit,line,length,ierr)
        if(ierr/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
          return
        end if
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
              call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
          return
        end if
        pos = length+1
      end do
!CHECK
      tag(res-1:res-1) = " "
      tag(res-pos+pos1:res-2) = line(pos1+1:pos-1)
      tag(1:len(tag)-res+pos-pos1+1)  =tag(res-pos+pos1:len(tag))
!write(0,*) "%%%%"//tag(1:len(tag)-res+pos-pos1+1)//"%%%%"
      read(unit,"(a)",iostat=iostat,advance="no") line(1:pos1-1)
      if(iostat/=0) then
            call iotk_error_issue(ierr,"iotk_scan_tag",__FILE__,__LINE__)
        return
      end if
!      pos1 = len_trim(tag(1:len(tag)-res+pos-pos1+1))
      pos1 = len(tag)-res+pos-pos1+1-1
!      pos = verify(tag," ")
      pos = 1
    end if
    tag(pos1+1:pos1+1) = iotk_eos
!    write(0,*) "**",direction,"%"//(tag(1:iotk_strlen(tag)))//"%",pos,pos1
! UNA VOLTA RISISTEMATO SOPRA, FARE CONTROLLI PIU' STRINGENTI QUI
    if(tag(pos:pos)=="/" .and. tag(pos1:pos1)/="/") then
      control = 2
      tag = tag(pos+1:pos1)//iotk_eos
    else if(tag(pos:pos)/="/" .and. tag(pos1:pos1)=="/") then
      control = 3
      tag = tag(pos:pos1-1)//iotk_eos
    else if(tag(pos:pos)=="?" .and. tag(pos1:pos1)=="?") then
      control = 5
      tag = tag(pos+1:pos1-1)//iotk_eos
    else if(tag(pos:pos+2)=="!--" .and. tag(pos1-1:pos1)=="--") then
      control = 4
      tag = tag(pos+3:pos1-2)//iotk_eos
    else
      control = 1
      tag = tag(pos:pos1)//iotk_eos
    end if
!    write(0,*) "**",control,"%"//(tag(1:iotk_strlen(tag)))//"%"
  end if
end subroutine iotk_scan_tag_x

subroutine iotk_scan_x(unit,direction,control,name,attr,binary,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                 intent(in)  :: unit
  integer,                 intent(in)  :: direction
  integer,                 intent(in)  :: control
  character(iotk_namlenx), intent(in)  :: name
  character(iotk_attlenx), intent(out) :: attr
  logical,                 intent(in)  :: binary
  integer,                 intent(out) :: ierr

  character(iotk_taglenx) :: tag
  character(iotk_namlenx) :: r_name
  integer :: level,r_control,pos,pos1
  logical :: lall,match

  ierr = 0
  if(control==2 .and. direction<0) then
        call iotk_error_issue(ierr,"iotk_scan",__FILE__,__LINE__)
    return
  end if
  level = 0
  ierr = 0
  do
    lall=.false.
    if(direction>=0 .and. level==0) lall=.true.
    if(direction<0  .and. level==0 .and. control/=1) lall=.true.
    if(direction<0  .and. level==1 .and. control==1) lall=.true.
    call iotk_scan_tag(unit,direction,r_control,tag,binary,ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_scan",__FILE__,__LINE__)
      return
    end if
    if(r_control==4) cycle
    if(lall .or. r_control==5) then
      call iotk_tag_parse(tag,r_name,attr,ierr)
      if(ierr/=0) then
            call iotk_error_issue(ierr,"iotk_scan",__FILE__,__LINE__)
        call iotk_error_write(ierr,"direction",direction)
        call iotk_error_write(ierr,"control",control)
        return
      end if
    end if
    match = lall .and. r_control==control .and. r_name==name
    if(r_control==5) then
      if(r_name=="iotk") then
        call check_iotk_attr(unit,attr,ierr)
        if(ierr/=0) then
              call iotk_error_issue(ierr,"iotk_scan",__FILE__,__LINE__)
          return
        end if
      end if
    end if
    select case(direction)
    case(0:)
      select case(r_control)
      case(1)
        if(level==0 .and. match) exit
        level = level + 1
      case(2)
        if(level==0 .and. match) exit
        if(level==0) then
          call iotk_scan_tag(unit,-1,r_control,tag,binary,ierr)
          if(ierr/=0) then
                call iotk_error_issue(ierr,"iotk_scan",__FILE__,__LINE__)
            return
          end if
              call iotk_error_issue(ierr,"iotk_scan",__FILE__,__LINE__)
          ierr = - ierr
          return
        end if
        level = level - 1
      case(3)
        if(level==0 .and. match) exit
      case(5)
        if(level==0 .and. match) exit
      end select
    case(:-1)
      select case(r_control)
      case(2)
        level = level + 1
      case(1)
        if(level==1 .and. match) exit
        if(level==0) then
          call iotk_scan_tag(unit,+1,r_control,tag,binary,ierr)
          if(ierr/=0) then
                call iotk_error_issue(ierr,"iotk_scan",__FILE__,__LINE__)
            return
          end if
              call iotk_error_issue(ierr,"iotk_scan",__FILE__,__LINE__)
          ierr = - ierr
          return
        end if
        level = level - 1
      case(3)
        if(level==0 .and. match) exit
      case(5)
        if(level==0 .and. match) exit
      end select
    end select
  end do
  if(direction<0) then
    call iotk_scan_tag(unit,+1,r_control,tag,binary,ierr)
    if(ierr/=0) then
          call iotk_error_issue(ierr,"iotk_scan",__FILE__,__LINE__)
    end if
  end if
end subroutine iotk_scan_x

subroutine iotk_getline_x(unit,line,length,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  integer,            intent(in)  :: unit
  character(len=*),   intent(out) :: line
  integer, optional,  intent(out) :: length
  integer, optional,  intent(out) :: ierr
  integer :: iostat
#ifdef __IOTK_WORKAROUND1
  character(len=iotk_linlenx) :: buffer
#else
  character(len=iotk_getline_buffer) :: buffer
#endif
  integer :: pos,buflen,ierrl,pos1
  logical :: eor
  pos = 0
  ierrl=0
#ifdef __IOTK_WORKAROUND1
  read(unit,"(a)",iostat=iostat) buffer
  if(iostat/=0) then
        call iotk_error_issue(ierrl,"iotk_getline",__FILE__,__LINE__)
    goto 2
  end if
  buflen = len_trim(buffer)
  line(1:buflen) = buffer(1:buflen)
  line(buflen+1:buflen+1) = iotk_eos
  if(present(length)) length = buflen
#else
  do
    eor = .true.
    read(unit,"(a)",iostat=iostat,eor=1,size=buflen,advance="no") buffer
3   continue
    eor = .false.
    if(iostat/=0) then
          call iotk_error_issue(ierrl,"iotk_getline",__FILE__,__LINE__)
      call iotk_error_write(ierrl,"iostat",iostat)
      goto 2
    end if
1   continue
    if(buflen==0) exit
    pos1 = min(pos+buflen,len(line))
    line(pos+1:pos1) = buffer(1:pos1-pos)
    pos = pos1
    if(eor .or. pos>=len(line)) exit
  end do
  if(pos<len(line)) line(pos+1:pos+1) = iotk_eos
  if(present(length)) length = pos
  if(pos>=len(line)) then
        call iotk_error_issue(ierrl,"iotk_getline",__FILE__,__LINE__)
    call iotk_error_msg(ierrl,'Line too long')
    read(unit,*,iostat=iostat)
    if(iostat/=0) then
          call iotk_error_issue(ierrl,"iotk_getline",__FILE__,__LINE__)
      call iotk_error_write(ierrl,"iostat",iostat)
      goto 2
    end if
  end if
#endif
2 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error_handler(ierrl)
  end if
  
end subroutine iotk_getline_x

function iotk_index_scal(index)
  use iotk_base
  use iotk_interface
  integer,           intent(in) :: index
  character(len=range(index)+3) :: iotk_index_scal
  iotk_index_scal="."//iotk_itoa(index)
end function iotk_index_scal
  
function iotk_index_vec(index)
  use iotk_base
  use iotk_interface
  implicit none
  integer,                         intent(in) :: index(:)
  character(len=(range(index)+3)*size(index)) :: iotk_index_vec
  integer :: length,i
  length = 0
  iotk_index_vec = " "
  do i = 1,size(index)
    iotk_index_vec(length+1:length+1+(range(index)+3)) = "."//iotk_itoa(index(i))
    length = len_trim(iotk_index_vec)
  end do
end function iotk_index_vec


subroutine iotk_tag_parse_x(tag,name,attr,ierr)
  use iotk_base
  use iotk_interface
  implicit none
  character(iotk_taglenx), intent(in)  :: tag
  character(iotk_namlenx), intent(out) :: name
  character(iotk_attlenx), intent(out) :: attr
  integer,                 intent(out) :: ierr
  integer :: pos,lenatt,lentag
  ierr = 0
  lentag=iotk_strlen(tag)
  if(verify(tag(1:1),iotk_namcharfirst)/=0) then
        call iotk_error_issue(ierr,"iotk_tag_parse",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'Wrong syntax in tag')
    call iotk_error_write(ierr,"tag",tag(1:lentag))
    return
  end if
  pos = scan(tag(1:lentag)," ")
  if(pos==0) pos=lentag+1
  if(pos>len(name)+1) then
        call iotk_error_issue(ierr,"iotk_tag_parse",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'Tag name too long')
    return
   end if
  name = tag(1:pos-1)
  lenatt = len_trim(tag(pos:lentag))
  if(lenatt>iotk_attlenx) then
        call iotk_error_issue(ierr,"iotk_tag_parse",__FILE__,__LINE__)
    call iotk_error_msg(ierr,'Attribute string too long')
    return
  end if
  if(lenatt>0) then
    attr(1:lenatt) = tag(pos:pos+lenatt-1)
    if(lenatt+1<=len(attr)) attr(lenatt+1:lenatt+1)=iotk_eos
  else
    attr(1:1)=iotk_eos
  end if
end subroutine iotk_tag_parse_x

function iotk_complete_filepath_x(newfile,oldfile)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*), intent(in) :: newfile
  character(len=*), intent(in) :: oldfile
  character(len=len(newfile)+len(oldfile)) :: iotk_complete_filepath_x
  character(len=len(oldfile)) :: prefix
  integer :: pos
  if(newfile(1:1)=="/") then
    iotk_complete_filepath_x = newfile
  else
    pos = scan(oldfile,"/",back=.true.)
    prefix = " "
    if(pos>0) prefix = oldfile(1:pos)
    iotk_complete_filepath_x = trim(prefix)//trim(newfile)
  end if
end function iotk_complete_filepath_x

function iotk_check_name_x(name)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*), intent(in) :: name
  logical                      :: iotk_check_name_x
! Checks a single name
  integer :: len_name
  iotk_check_name_x = .true.
  len_name = len_trim(name)
  if(len_name>iotk_namlenx) iotk_check_name_x = .false.
  if(verify(name(1:1),iotk_namcharfirst)/=0) iotk_check_name_x = .false.
  if(len_name>1) then
    if(verify(name(2:len_name),iotk_namchar)/=0) iotk_check_name_x = .false.
  end if
end function iotk_check_name_x

function iotk_atol_x(a,check)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*),  intent(in)  :: a
  logical, optional, intent(out) :: check
  logical :: iotk_atol_x
  integer :: i
  iotk_atol_x = .false.
  if(present(check)) check = .false.
  if(len(a)==0) return
  do i = 1 , len(a)
    if(a(i:i)/=" " .and. a(i:i)/=".") exit
  end do
  if(i>len(a)) return
  if(present(check)) check = .true.
  if(a(i:i)=="T" .or. a(i:i)=="t") then
    iotk_atol_x = .true.
  else if(a(i:i)=="F" .or. a(i:i)=="f") then
    iotk_atol_x = .false.
  else
    if(present(check)) check = .false.
  end if
end function iotk_atol_x

#ifdef __IOTK_INTEGER1
subroutine iotk_atoi1(i,a,check)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*),                  intent(in)  :: a
  logical, optional,                 intent(out) :: check
  integer(kind=__IOTK_INTEGER1), intent(out) :: i
  logical :: minus
  integer :: pos,index,ii
! AGGIUNGERE DEI CHECK SULL'OVERFLOW
  minus = .false.
  i = 0
  if(present(check)) check = .false.
  if(len(a)==0) return
  do ii = 1 , len(a)
    if(a(ii:ii)/=" ") exit
  end do
  if(ii>len(a)) return
  if(a(ii:ii)=="-") then
    minus = .true.
    ii = ii + 1
  else if(a(ii:ii)=="+") then
    ii = ii + 1
  end if
  if(ii>len(a)) return
  pos = ii
  do ii=pos,len(a)
    index = iachar(a(ii:ii)) - iachar("0")
    if(index<0 .or. index>9) exit
    i = i*10 + index
  end do
  if(minus) i = - i
  if(present(check)) then
    pos = ii
    do ii=pos,len(a)
      if(a(ii:ii)/=" ") return
    end do
    check = .true.
  end if
end subroutine iotk_atoi1
#endif
#ifdef __IOTK_INTEGER2
subroutine iotk_atoi2(i,a,check)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*),                  intent(in)  :: a
  logical, optional,                 intent(out) :: check
  integer(kind=__IOTK_INTEGER2), intent(out) :: i
  logical :: minus
  integer :: pos,index,ii
! AGGIUNGERE DEI CHECK SULL'OVERFLOW
  minus = .false.
  i = 0
  if(present(check)) check = .false.
  if(len(a)==0) return
  do ii = 1 , len(a)
    if(a(ii:ii)/=" ") exit
  end do
  if(ii>len(a)) return
  if(a(ii:ii)=="-") then
    minus = .true.
    ii = ii + 1
  else if(a(ii:ii)=="+") then
    ii = ii + 1
  end if
  if(ii>len(a)) return
  pos = ii
  do ii=pos,len(a)
    index = iachar(a(ii:ii)) - iachar("0")
    if(index<0 .or. index>9) exit
    i = i*10 + index
  end do
  if(minus) i = - i
  if(present(check)) then
    pos = ii
    do ii=pos,len(a)
      if(a(ii:ii)/=" ") return
    end do
    check = .true.
  end if
end subroutine iotk_atoi2
#endif
#ifdef __IOTK_INTEGER3
subroutine iotk_atoi3(i,a,check)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*),                  intent(in)  :: a
  logical, optional,                 intent(out) :: check
  integer(kind=__IOTK_INTEGER3), intent(out) :: i
  logical :: minus
  integer :: pos,index,ii
! AGGIUNGERE DEI CHECK SULL'OVERFLOW
  minus = .false.
  i = 0
  if(present(check)) check = .false.
  if(len(a)==0) return
  do ii = 1 , len(a)
    if(a(ii:ii)/=" ") exit
  end do
  if(ii>len(a)) return
  if(a(ii:ii)=="-") then
    minus = .true.
    ii = ii + 1
  else if(a(ii:ii)=="+") then
    ii = ii + 1
  end if
  if(ii>len(a)) return
  pos = ii
  do ii=pos,len(a)
    index = iachar(a(ii:ii)) - iachar("0")
    if(index<0 .or. index>9) exit
    i = i*10 + index
  end do
  if(minus) i = - i
  if(present(check)) then
    pos = ii
    do ii=pos,len(a)
      if(a(ii:ii)/=" ") return
    end do
    check = .true.
  end if
end subroutine iotk_atoi3
#endif
#ifdef __IOTK_INTEGER4
subroutine iotk_atoi4(i,a,check)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*),                  intent(in)  :: a
  logical, optional,                 intent(out) :: check
  integer(kind=__IOTK_INTEGER4), intent(out) :: i
  logical :: minus
  integer :: pos,index,ii
! AGGIUNGERE DEI CHECK SULL'OVERFLOW
  minus = .false.
  i = 0
  if(present(check)) check = .false.
  if(len(a)==0) return
  do ii = 1 , len(a)
    if(a(ii:ii)/=" ") exit
  end do
  if(ii>len(a)) return
  if(a(ii:ii)=="-") then
    minus = .true.
    ii = ii + 1
  else if(a(ii:ii)=="+") then
    ii = ii + 1
  end if
  if(ii>len(a)) return
  pos = ii
  do ii=pos,len(a)
    index = iachar(a(ii:ii)) - iachar("0")
    if(index<0 .or. index>9) exit
    i = i*10 + index
  end do
  if(minus) i = - i
  if(present(check)) then
    pos = ii
    do ii=pos,len(a)
      if(a(ii:ii)/=" ") return
    end do
    check = .true.
  end if
end subroutine iotk_atoi4
#endif

#ifdef __IOTK_INTEGER1
function iotk_itoa1(i,length)
  use iotk_base
  use iotk_interface
  implicit none
  integer(kind=__IOTK_INTEGER1), intent(in)  :: i
  integer, optional, intent(out)                 :: length
  character(len=range(i)+2) :: iotk_itoa1
  integer(kind=__IOTK_INTEGER1) :: itmp
  integer :: pos,pos1
  character(len=range(i)+2) :: tmp
  itmp = abs(i)
  do pos = 1 , len(tmp)
    tmp(pos:pos) = achar( modulo(itmp,int(10,kind(itmp))) + iachar("0") )
    itmp = itmp/10
    if(itmp==0) exit
    if(pos==len(tmp)) exit
  end do
  if(i<0) then
    tmp(pos+1:pos+1)="-"
    pos = pos + 1
  end if
  do pos1=1,pos
    iotk_itoa1(pos1:pos1) = tmp(pos-pos1+1:pos-pos1+1)
  end do
  if(present(length)) length = pos
  do pos1=pos+1,len(iotk_itoa1)
    iotk_itoa1(pos1:pos1) = " "
  end do
end function iotk_itoa1
#endif
#ifdef __IOTK_INTEGER2
function iotk_itoa2(i,length)
  use iotk_base
  use iotk_interface
  implicit none
  integer(kind=__IOTK_INTEGER2), intent(in)  :: i
  integer, optional, intent(out)                 :: length
  character(len=range(i)+2) :: iotk_itoa2
  integer(kind=__IOTK_INTEGER2) :: itmp
  integer :: pos,pos1
  character(len=range(i)+2) :: tmp
  itmp = abs(i)
  do pos = 1 , len(tmp)
    tmp(pos:pos) = achar( modulo(itmp,int(10,kind(itmp))) + iachar("0") )
    itmp = itmp/10
    if(itmp==0) exit
    if(pos==len(tmp)) exit
  end do
  if(i<0) then
    tmp(pos+1:pos+1)="-"
    pos = pos + 1
  end if
  do pos1=1,pos
    iotk_itoa2(pos1:pos1) = tmp(pos-pos1+1:pos-pos1+1)
  end do
  if(present(length)) length = pos
  do pos1=pos+1,len(iotk_itoa2)
    iotk_itoa2(pos1:pos1) = " "
  end do
end function iotk_itoa2
#endif
#ifdef __IOTK_INTEGER3
function iotk_itoa3(i,length)
  use iotk_base
  use iotk_interface
  implicit none
  integer(kind=__IOTK_INTEGER3), intent(in)  :: i
  integer, optional, intent(out)                 :: length
  character(len=range(i)+2) :: iotk_itoa3
  integer(kind=__IOTK_INTEGER3) :: itmp
  integer :: pos,pos1
  character(len=range(i)+2) :: tmp
  itmp = abs(i)
  do pos = 1 , len(tmp)
    tmp(pos:pos) = achar( modulo(itmp,int(10,kind(itmp))) + iachar("0") )
    itmp = itmp/10
    if(itmp==0) exit
    if(pos==len(tmp)) exit
  end do
  if(i<0) then
    tmp(pos+1:pos+1)="-"
    pos = pos + 1
  end if
  do pos1=1,pos
    iotk_itoa3(pos1:pos1) = tmp(pos-pos1+1:pos-pos1+1)
  end do
  if(present(length)) length = pos
  do pos1=pos+1,len(iotk_itoa3)
    iotk_itoa3(pos1:pos1) = " "
  end do
end function iotk_itoa3
#endif
#ifdef __IOTK_INTEGER4
function iotk_itoa4(i,length)
  use iotk_base
  use iotk_interface
  implicit none
  integer(kind=__IOTK_INTEGER4), intent(in)  :: i
  integer, optional, intent(out)                 :: length
  character(len=range(i)+2) :: iotk_itoa4
  integer(kind=__IOTK_INTEGER4) :: itmp
  integer :: pos,pos1
  character(len=range(i)+2) :: tmp
  itmp = abs(i)
  do pos = 1 , len(tmp)
    tmp(pos:pos) = achar( modulo(itmp,int(10,kind(itmp))) + iachar("0") )
    itmp = itmp/10
    if(itmp==0) exit
    if(pos==len(tmp)) exit
  end do
  if(i<0) then
    tmp(pos+1:pos+1)="-"
    pos = pos + 1
  end if
  do pos1=1,pos
    iotk_itoa4(pos1:pos1) = tmp(pos-pos1+1:pos-pos1+1)
  end do
  if(present(length)) length = pos
  do pos1=pos+1,len(iotk_itoa4)
    iotk_itoa4(pos1:pos1) = " "
  end do
end function iotk_itoa4
#endif

#ifdef __IOTK_LOGICAL1
function iotk_ltoa1(l)
  use iotk_base
  use iotk_interface
  implicit none
  logical(kind=__IOTK_LOGICAL1), intent(in) :: l
  character                                     :: iotk_ltoa1
  if(l) then
    iotk_ltoa1 = "T"
  else
    iotk_ltoa1 = "F"
  end if
end function iotk_ltoa1
#endif
#ifdef __IOTK_LOGICAL2
function iotk_ltoa2(l)
  use iotk_base
  use iotk_interface
  implicit none
  logical(kind=__IOTK_LOGICAL2), intent(in) :: l
  character                                     :: iotk_ltoa2
  if(l) then
    iotk_ltoa2 = "T"
  else
    iotk_ltoa2 = "F"
  end if
end function iotk_ltoa2
#endif
#ifdef __IOTK_LOGICAL3
function iotk_ltoa3(l)
  use iotk_base
  use iotk_interface
  implicit none
  logical(kind=__IOTK_LOGICAL3), intent(in) :: l
  character                                     :: iotk_ltoa3
  if(l) then
    iotk_ltoa3 = "T"
  else
    iotk_ltoa3 = "F"
  end if
end function iotk_ltoa3
#endif
#ifdef __IOTK_LOGICAL4
function iotk_ltoa4(l)
  use iotk_base
  use iotk_interface
  implicit none
  logical(kind=__IOTK_LOGICAL4), intent(in) :: l
  character                                     :: iotk_ltoa4
  if(l) then
    iotk_ltoa4 = "T"
  else
    iotk_ltoa4 = "F"
  end if
end function iotk_ltoa4
#endif

function iotk_basefmt_x(type,ikind,ilen)
  use iotk_base
  use iotk_interface
  implicit none
  character(100)           :: iotk_basefmt_x
  integer,      intent(in) :: ikind,ilen
  character(*), intent(in) :: type
  integer :: nexp,exp,ndig,baselen
  logical, save :: first_call = .true.
#ifdef __IOTK_INTEGER1
  integer (__IOTK_INTEGER1) :: example_INTEGER1
  character(46), save :: save_basefmt_integer1 = ""
#endif
#ifdef __IOTK_REAL1
  real (__IOTK_REAL1) :: example_REAL1
  character(46), save :: save_basefmt_real1 = ""
#endif
#ifdef __IOTK_INTEGER2
  integer (__IOTK_INTEGER2) :: example_INTEGER2
  character(46), save :: save_basefmt_integer2 = ""
#endif
#ifdef __IOTK_REAL2
  real (__IOTK_REAL2) :: example_REAL2
  character(46), save :: save_basefmt_real2 = ""
#endif
#ifdef __IOTK_INTEGER3
  integer (__IOTK_INTEGER3) :: example_INTEGER3
  character(46), save :: save_basefmt_integer3 = ""
#endif
#ifdef __IOTK_REAL3
  real (__IOTK_REAL3) :: example_REAL3
  character(46), save :: save_basefmt_real3 = ""
#endif
#ifdef __IOTK_INTEGER4
  integer (__IOTK_INTEGER4) :: example_INTEGER4
  character(46), save :: save_basefmt_integer4 = ""
#endif
#ifdef __IOTK_REAL4
  real (__IOTK_REAL4) :: example_REAL4
  character(46), save :: save_basefmt_real4 = ""
#endif
  if(first_call) then
#ifdef __IOTK_INTEGER1
    baselen = range(example_INTEGER1) + 1
    save_basefmt_integer1 = "(i"//trim(iotk_itoa(baselen))//")"
#endif
#ifdef __IOTK_REAL1
    ndig = precision(example_REAL1)+1
    exp = range(example_REAL1)+1
    nexp = 1
    do
      if(exp < 10) exit
      exp = exp / 10
      nexp = nexp + 1
    end do
    baselen = nexp+ndig-1+5
    save_basefmt_real1 = "(ES"//trim(iotk_itoa(baselen))//"." &
                //trim(iotk_itoa(ndig-1))//"E"//trim(iotk_itoa(nexp))//")"

#endif
#ifdef __IOTK_INTEGER2
    baselen = range(example_INTEGER2) + 1
    save_basefmt_integer2 = "(i"//trim(iotk_itoa(baselen))//")"
#endif
#ifdef __IOTK_REAL2
    ndig = precision(example_REAL2)+1
    exp = range(example_REAL2)+1
    nexp = 1
    do
      if(exp < 10) exit
      exp = exp / 10
      nexp = nexp + 1
    end do
    baselen = nexp+ndig-1+5
    save_basefmt_real2 = "(ES"//trim(iotk_itoa(baselen))//"." &
                //trim(iotk_itoa(ndig-1))//"E"//trim(iotk_itoa(nexp))//")"

#endif
#ifdef __IOTK_INTEGER3
    baselen = range(example_INTEGER3) + 1
    save_basefmt_integer3 = "(i"//trim(iotk_itoa(baselen))//")"
#endif
#ifdef __IOTK_REAL3
    ndig = precision(example_REAL3)+1
    exp = range(example_REAL3)+1
    nexp = 1
    do
      if(exp < 10) exit
      exp = exp / 10
      nexp = nexp + 1
    end do
    baselen = nexp+ndig-1+5
    save_basefmt_real3 = "(ES"//trim(iotk_itoa(baselen))//"." &
                //trim(iotk_itoa(ndig-1))//"E"//trim(iotk_itoa(nexp))//")"

#endif
#ifdef __IOTK_INTEGER4
    baselen = range(example_INTEGER4) + 1
    save_basefmt_integer4 = "(i"//trim(iotk_itoa(baselen))//")"
#endif
#ifdef __IOTK_REAL4
    ndig = precision(example_REAL4)+1
    exp = range(example_REAL4)+1
    nexp = 1
    do
      if(exp < 10) exit
      exp = exp / 10
      nexp = nexp + 1
    end do
    baselen = nexp+ndig-1+5
    save_basefmt_real4 = "(ES"//trim(iotk_itoa(baselen))//"." &
                //trim(iotk_itoa(ndig-1))//"E"//trim(iotk_itoa(nexp))//")"

#endif
    first_call = .false.
  end if
  select case(type)
  case("LOGICAL")
    iotk_basefmt_x = "(l1)"
  case("INTEGER")
    select case(ikind)
#ifdef __IOTK_INTEGER1
    case(__IOTK_INTEGER1)
      iotk_basefmt_x = save_basefmt_integer1
#endif
#ifdef __IOTK_INTEGER2
    case(__IOTK_INTEGER2)
      iotk_basefmt_x = save_basefmt_integer2
#endif
#ifdef __IOTK_INTEGER3
    case(__IOTK_INTEGER3)
      iotk_basefmt_x = save_basefmt_integer3
#endif
#ifdef __IOTK_INTEGER4
    case(__IOTK_INTEGER4)
      iotk_basefmt_x = save_basefmt_integer4
#endif
    end select
  case("REAL")
    select case(ikind)
#ifdef __IOTK_REAL1
    case(__IOTK_REAL1)
      iotk_basefmt_x = save_basefmt_real1
#endif
#ifdef __IOTK_REAL2
    case(__IOTK_REAL2)
      iotk_basefmt_x = save_basefmt_real2
#endif
#ifdef __IOTK_REAL3
    case(__IOTK_REAL3)
      iotk_basefmt_x = save_basefmt_real3
#endif
#ifdef __IOTK_REAL4
    case(__IOTK_REAL4)
      iotk_basefmt_x = save_basefmt_real4
#endif
    end select
  case("COMPLEX")
    select case(ikind)
#ifdef __IOTK_REAL1
    case(__IOTK_REAL1)
      iotk_basefmt_x = "("//trim(save_basefmt_real1)//",',',"//trim(save_basefmt_real1)//")"
#endif
#ifdef __IOTK_REAL2
    case(__IOTK_REAL2)
      iotk_basefmt_x = "("//trim(save_basefmt_real2)//",',',"//trim(save_basefmt_real2)//")"
#endif
#ifdef __IOTK_REAL3
    case(__IOTK_REAL3)
      iotk_basefmt_x = "("//trim(save_basefmt_real3)//",',',"//trim(save_basefmt_real3)//")"
#endif
#ifdef __IOTK_REAL4
    case(__IOTK_REAL4)
      iotk_basefmt_x = "("//trim(save_basefmt_real4)//",',',"//trim(save_basefmt_real4)//")"
#endif
    end select
  case("CHARACTER")
    if(ilen>=0) then
      iotk_basefmt_x = "(a"//trim(iotk_itoa(ilen))//")"
    else
      iotk_basefmt_x = "(a)"
    end if
  end select
end function iotk_basefmt_x

function iotk_wfmt_x(type,ikind,isize,ilen,fmt)
  use iotk_base
  use iotk_interface
  implicit none
  integer,       intent(in)  :: ikind
  character(*),  intent(in)  :: type
  integer,       intent(in)  :: isize
  integer,       intent(in)  :: ilen
  character(*),  intent(in)  :: fmt
  character(150)             :: iotk_wfmt_x
  if(fmt/="!") then
    iotk_wfmt_x = fmt
    return
  end if
  if(isize==1) then
    iotk_wfmt_x = "("//trim(iotk_basefmt(type,ikind,ilen))//")"
  else
    iotk_wfmt_x = "("//trim(iotk_itoa(isize))//"("//trim(iotk_basefmt(type,ikind,ilen)) &
                //",:,','))"
  end if
!write(0,*) "FMT:"//trim(iotk_wfmt_x)
end function iotk_wfmt_x

function iotk_toupper_x(str)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*), intent(in) :: str
  character(len=len(str))      :: iotk_toupper_x
  integer :: i,pos
  do i = 1,len(str)
    if(str(i:i)==iotk_eos) exit
    pos=scan(lowalphabet,str(i:i))
    if(pos==0) then
      iotk_toupper_x(i:i) = str(i:i)
    else
      iotk_toupper_x(i:i) = upalphabet(pos:pos)
    end if
  end do
  if(i<=len(iotk_toupper_x)) iotk_toupper_x(i:i) = iotk_eos
end function iotk_toupper_x

function iotk_tolower_x(str)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*), intent(in) :: str
  character(len=len(str))      :: iotk_tolower_x
  integer :: i,pos
  do i = 1,len(str)
    if(str(i:i)==iotk_eos) exit
    pos=scan(upalphabet,str(i:i))
    if(pos==0) then
      iotk_tolower_x(i:i) = str(i:i)
    else
      iotk_tolower_x(i:i) = lowalphabet(pos:pos)
    end if
  end do
  if(i<=len(iotk_tolower_x)) iotk_tolower_x(i:i) = iotk_eos
end function iotk_tolower_x

subroutine iotk_escape_x(to,from)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*), intent(in) :: from
  character(len=*), intent(out):: to
  integer :: pos,pos1,semic,fromlen
  pos = 1
  pos1 = 1
  fromlen = iotk_strlen(from)
  do  
    if(pos>fromlen) exit
    if(from(pos:pos)=="&" .and. pos/=fromlen) then
      semic = scan(from(pos+1:fromlen),";")
      if(semic<=1) to(pos1:pos1)="&"
      select case(from(pos+1:pos+semic-1))
      case("amp")
        to(pos1:pos1)="&"
      case("lt")
        to(pos1:pos1)="<"
      case("gt")
        to(pos1:pos1)=">"
      case("quot")
        to(pos1:pos1)='"'
      case("apos")
        to(pos1:pos1)="'"
      case default
        to(pos1:pos1+semic) = from(pos:pos+semic)
        pos1 = pos1 + semic
      end select
      pos = pos + semic
    else
      to(pos1:pos1)=from(pos:pos)
    end if
    pos = pos + 1
    pos1 = pos1 + 1
    if(pos1>len(to)) exit
  end do  
  if(pos1<=len(to)) to(pos1:pos1)=iotk_eos
end subroutine iotk_escape_x

subroutine iotk_deescape_x(to,from,quot,apos)
  use iotk_base
  use iotk_interface
  implicit none
  character(len=*), intent(in)  :: from
  character(len=*), intent(out) :: to
  logical, optional, intent(in) :: quot,apos
  logical :: lquot,lapos
  integer :: pos,pos1
  lquot=.false.
  lapos=.false.
  if(present(quot)) lquot = quot
  if(present(apos)) lapos = apos
  pos = 1
  pos1 = 1
  do
    if(pos>len(from) .or. pos1>len(to)) exit ! i due test devono essere separati
    if(from(pos:pos)==iotk_eos) exit
    select case(from(pos:pos))
    case("&")
      if(pos1+4<=len(to)) to(pos1:pos1+4)="&amp;"
      pos1=pos1+4
    case("<")
      if(pos1+3<=len(to)) to(pos1:pos1+3)="&lt;"
      pos1=pos1+3
    case(">")
      if(pos1+3<=len(to)) to(pos1:pos1+3)="&gt;"
      pos1=pos1+3
    case('"')
      if(lquot) then
        if(pos1+5<=len(to)) to(pos1:pos1+5)="&quot;"
        pos1=pos1+5
      else
        to(pos1:pos1) = from(pos:pos)
      end if
    case("'")
      if(lapos) then
        if(pos1+5<=len(to)) to(pos1:pos1+5)="&apos;"
        pos1=pos1+5
      else
        to(pos1:pos1) = from(pos:pos)
      end if
    case default
      to(pos1:pos1) = from(pos:pos)
    end select
    pos = pos + 1
    pos1 = pos1 + 1
  end do
  if(pos1<=len(to)) to(pos1:pos1)=iotk_eos
end subroutine iotk_deescape_x
