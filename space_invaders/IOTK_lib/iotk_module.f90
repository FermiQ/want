!
! Input/Output Tool Kit (IOTK) 0.2.10
! Copyright (C) 2004 Giovanni Bussi
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Lesser General Public
! License as published by the Free Software Foundation; either
! version 2.1 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Lesser General Public License for more details.
!
! You should have received a copy of the GNU Lesser General Public
! License along with this library; if not, write to the Free Software
! Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
!
! PLEASE DO NOT EDIT THIS FILE !
! THIS FILE HAS BEEN GENERATED AUTOMATICALLY WITH
! SPREP 0.2.0 ON Wed Nov 10 11:53:58 NFT 2004
! THE REAL SOURCE IS FILE iotk.in
!
!------------------------------------------------------------------------------!
! Input/Output Tool Kit (IOTK)
! version: 0.2.10
! contact: gbussi@unimore.it
!------------------------------------------------------------------------------!

module iotk_module
! This module is a wrapper for the entities in iotk_base
! which need to be public and also contains some high-level routines
  use iotk_base
! All names are private ...
  private
! ... except the names listed below
  public :: iotk_open_write
  public :: iotk_open_read
  public :: iotk_close_write
  public :: iotk_close_read
  public :: iotk_write_begin
  public :: iotk_write_end
  public :: iotk_write_pi
  public :: iotk_write_empty
  public :: iotk_write_dat
  public :: iotk_write_attr
  public :: iotk_scan_begin
  public :: iotk_scan_end
  public :: iotk_scan_pi
  public :: iotk_scan_empty
  public :: iotk_scan_dat
  public :: iotk_scan_attr
  public :: iotk_taglenx
  public :: iotk_attlenx
  public :: iotk_vallenx
  public :: iotk_namlenx
  public :: iotk_index
  public :: iotk_version
  public :: iotk_binary_format
  public :: iotk_last_iostat
  public :: iotk_header_kind
  public :: iotk_copy_tag
  public :: iotk_unit_print
  public :: iotk_unit_get
  public :: iotk_free_unit
  public :: iotk_basefmt
  public :: iotk_wfmt
  public :: iotk_newline
  public :: iotk_eof
  public :: iotk_defkind_character
  public :: iotk_defkind_logical
  public :: iotk_defkind_integer
  public :: iotk_defkind_real
  public :: iotk_defkind_complex

contains

subroutine iotk_open_write(unit,file,binary,new,root,ierr)
  integer,                intent(in)  :: unit
  character(*), optional, intent(in)  :: file
  logical,      optional, intent(in)  :: binary
  logical,      optional, intent(in)  :: new
  character(*), optional, intent(in)  :: root
  integer,      optional, intent(out) :: ierr
! Opens a file properly
  character(50) :: status,form
  character(iotk_namlenx) :: lroot
  character(iotk_attlenx) :: attr
  integer :: ierrl
  logical :: lbinary
  ierrl = 0
  if(present(file)) then
    form = "formatted"
    if(present(binary)) then
      if(binary) form = "unformatted"
    end if
    status = "unknown"
    if(present(new)) then
      if(new) status = "new"
    end if
    open(unit=unit,file=file,status=status,form=form, &
         position="rewind",iostat=iostat,action="write")
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) goto 1
  end if
  call iotk_inquire(unit,binary=lbinary,ierr=ierrl)
  if(ierrl/=0) goto 1
  if(.not. lbinary) write(unit,"(a)") '<?xml version="1.0"?>'
  call iotk_write_attr(attr,"version",iotk_version,first=.true.,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_write_pi(unit,"iotk",attr,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_write_attr(attr,"binary",lbinary,first=.true.,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_write_pi(unit,"iotk",attr,ierr=ierrl)
  if(ierrl/=0) goto 1
  if(lbinary) then
    call iotk_write_attr(attr,"binary_format",iotk_binary_format,first=.true.,ierr=ierrl)
    if(ierrl/=0) goto 1
    if(ierrl/=0) goto 1
    call iotk_write_pi(unit,"iotk",attr,ierr=ierrl)
  end if
  lroot = "Root"
  if(present(root)) lroot = root
  call iotk_write_begin(unit,lroot,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_unit_add(unit,root=lroot,ierr=ierrl)
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_open_write

subroutine iotk_close_write(unit,ierr)
  integer,                intent(in)  :: unit
  integer,      optional, intent(out) :: ierr
! Closes a file properly
  character(iotk_namlenx) :: lroot
  logical :: binary
  integer :: ierrl
  ierrl = 0
  call iotk_unit_get(unit,root=lroot,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_write_end(unit,lroot,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_inquire(unit,binary,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary) write(unit,*,iostat=iostat)
  if(iostat/=0) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_unit_del(unit,ierr=ierrl)
  if(ierrl/=0) goto 1
  close(unit,iostat=iostat)
  if(iostat/=0) ierrl = __LINE__
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_close_write

subroutine iotk_open_read(unit,file,binary,root,ierr)
  integer,                intent(in)  :: unit
  character(*), optional, intent(in)  :: file
  logical,      optional, intent(in)  :: binary
  character(*), optional, intent(out) :: root
  integer,      optional, intent(out) :: ierr
  character(50)           :: status,form
  character(iotk_attlenx) :: attr
  character(iotk_taglenx) :: tag
  character(iotk_namlenx) :: lroot
  integer                 :: ierrl,control
  logical                 :: lbinary,rbinary,iotk
  ierrl = 0
  if(present(file)) then
    if(present(binary)) then
      lbinary = binary
    else
      lbinary = .false.
    end if
    form = "formatted"
    if(lbinary) form = "unformatted"
    open(unit=unit,file=file,status="old",form=form,position="rewind",iostat=iostat,action="read")
    if(iostat/=0) ierrl = __LINE__
  end if
  if(ierrl/=0) goto 1
  call iotk_inquire(unit,binary=lbinary,ierr=ierrl)
  if(ierrl/=0) goto 1
  do
    call scan_tag(unit,+1,control,tag,lbinary,ierrl)
    if(ierrl/=0) goto 1
    select case(control)
    case(1)
      exit
    case(2:3)
      goto 1
    case(5)
      call tag_parse(tag,lroot,attr,ierrl)
      if(ierrl/=0) goto 1
      if(lroot=="iotk") call check_iotk_attr(unit,attr,ierrl)
      if(ierrl/=0) goto 1
    end select
  end do
  if(ierrl/=0) goto 1
  call tag_parse(tag,lroot,attr,ierrl)
  if(ierrl/=0) goto 1
  if(present(root)) root = lroot
  call iotk_unit_add(unit,lroot,ierr=ierrl)
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_open_read

subroutine iotk_close_read(unit,ierr)
  integer,                intent(in)  :: unit
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: lroot
  integer                 :: ierrl
  ierrl = 0
  call iotk_unit_get(unit,root=lroot,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_scan_end(unit,lroot,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_unit_del(unit,ierr=ierrl)
  if(ierrl/=0) goto 1
  close(unit,iostat=iostat)
  if(iostat/=0) ierrl=__LINE__
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_close_read

subroutine iotk_copy_tag(source,dest,maxsize,ierr)
  integer,           intent(in)  :: source
  integer,           intent(in)  :: dest
  integer, optional, intent(in)  :: maxsize
  integer, optional, intent(out) :: ierr
  logical :: source_binary,dest_binary
  integer :: ierrl,control,maxsizel
  character(iotk_taglenx) :: tag
  character(iotk_namlenx) :: name,root
  character(iotk_attlenx) :: attr
  character(iotk_vallenx) :: type
  maxsizel = -1
  if(present(maxsize)) maxsizel = maxsize
  call iotk_inquire(source,binary=source_binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_inquire(dest  ,binary=dest_binary,  ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_unit_get(source,root=root,ierr=ierrl)
  if(ierrl/=0) goto 1
  do
    call scan_tag(source,+1,control,tag,source_binary,ierrl)
    if(ierrl/=0) goto 1
    call tag_parse(tag,name,attr,ierrl)
    if(ierrl/=0) goto 1
    if(name == root) then
      call scan_tag(source,-1,control,tag,source_binary,ierrl)
      if(ierrl/=0) goto 1
      return
    end if
    call iotk_scan_attr(attr,"type",type,ierr=ierrl)
    if(ierrl/=0) then
      ierrl = 0
      type = " "
    end if
    if((type=="real" .or. type=="integer" .or. type=="logical" &
  .or. type=="character" .or. type=="complex") .and. control==1) then
      call iotk_copy_dat(source,dest,source_binary,dest_binary,name,attr,maxsize=maxsizel,ierr=ierrl)
      if(ierrl/=0) goto 1
      call scan_tag(source,+1,control,tag,source_binary,ierrl)
      if(ierrl/=0) goto 1
    else
      call write_tag(dest,control,tag,dest_binary,ierrl)
      if(ierrl/=0) goto 1
    end if
  end do
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_copy_tag

end module iotk_module


